[{"id":0,"href":"/BF/Background/Organizational-Structures/","title":"Background","section":"Background","content":"\rBackground\r#\rThe medical profession has an extensive, elaborate vocabulary to precisely name muscles, bones, organs, conditions and diseases. When a doctor says that a comatose patient has a left temporal lobe epidural hematoma, the intention is to enlighten, not to obfuscate.\nIn the software profession, we have many efforts that have helped us develop terms to discuss software, faults, failures, attacks and vulnerabilities, such as the Common Weakness Enumeration (CWE) [1] and Landwehr et. al. Taxonomy of Computer Program Security Flaws [2], but much work remains. We want to more accurately and precisely define software bugs or vulnerabilities. Consider that including \u0026ldquo;canary\u0026rdquo; values around arrays detects some buffer overflows while using address layout randomization mitigates other buffer overflows. A precise, orthogonal classification can state exactly which cases of buffer overflows each approach handles. We can also clearly state the classes of bugs that a tool can find and more easily determine if two tools generally find the same set of bugs or if they find different, complimentary sets.\nThrough centuries of experimentation and development of scientific principles, we now have the Periodic Table of Elements. Just as the structure of the periodic table reflects the underlying atomic structure, we are developing a taxonomy dictated by the \u0026ldquo;natural\u0026rdquo; organization of software bugs, while using as stepping stones known bugs enumerations, compendia and collections. For this and other analogies on what we are embarking on, we recall below some well-know organizational structures in science.\nScience has developed many different organizational structures. For example, the Periodic Table of Elements, the recently rearranged Tree of Life, the Geographic Coordinate System, and the Dewey Decimal Classification System.\nMendeleev\u0026rsquo;s Periodic Table\r#\rHowever obvious the Mendeleev\u0026rsquo;s Periodic Table seems today, it required extensive thought and investigation:\nGreeks used element and atom to name differences between materials and smallest parts of matter. In 330 BC, Aristotle proposed that everything is a mixture of \u0026ldquo;root elements\u0026rdquo;: Earth, Fire, Air, Water. Aristotle's Root Elements (Source: Reich Chemistry)\nIn the Middle Ages, alchemists made lists of materials, such as alcohol, sulfur, mercury, and salt.\nLavoisier created a list of 33 elements - e.g. oxygen, nitrogen, hydrogen, phosphorus, mercury, zinc, sulfur, light, and caloric, and distinguished metals from non-metals.\nDalton realized \u0026quot; atoms of same element are identical in all respects, particularly weight.\u0026quot;\nIn 1800s, several tables of elements were developed:\nDe Chancourtois first noticed periodicity of elements.When ordered by their atomic weights, similar elements occur at regular intervals.\nMendeleev\u0026rsquo;s Periodic Table in 1869 and his forecast of properties of missing elements reflected the century of growth in knowledge that reflects atomic structure: Columns correspond to the number of electrons in the outer shell and the fundamental chemical properties. Rows correspond to the number of electron shells.\nDiscovery of Chemical Elements - click on image for detailed view (Source: Wikimedia\rCommons)\nTree of Life\r#\rDiscoveries of more than 1,000 new types of bacteria and Archaea over the past 15 years have dramatically rejiggered the Tree of Life to account for these microscopic life forms. The new Tree of Life divides life into three domains: Bacteria, Archaea and Eukaryotes. It clearly shows that \u0026ldquo;life we see around us - plants, animals, humans and other so-called eukaryotes - represent a tiny percentage of the world\u0026rsquo;s biodiversity.\u0026rdquo;\nThe Tree of Life - click on image for detailed view (Source: Berkeley)\nGeographic Coordinate System\r#\rThe Geographic Coordinate System allows to specify any location on the Earth using Latitude, Longitude and Elevation. Longitude lines are perpendicular and latitude lines are parallel to the equator. Geographic Coordinate System (Source: Wikipedia) Dewey Decimal Classification System\r#\rThe Dewey Decimal Classification System allows new books and whole new subjects to be placed in reasonable locations in a library, for easy retrieval based on subject.\nCategories of Dewey Decimal Classification System. (Source: Appleton)\nReferences\r#\r[1] The MITRE Corporation. Common Weakness Enumeration (CWE).\n[2] C. E. Landwehr, A. R. Bull, J. P. McDermott, and W. S. Choi. A taxonomy of computer program security flaws, and examples. ACM Computing Surveys. vol. 26. no. 3. pp. 211-254. September 1994.\n"},{"id":1,"href":"/BF/Background/Overview/","title":"Background","section":"Background","content":"\rBackground\r#\rThe medical profession has an extensive, elaborate vocabulary to precisely name muscles, bones, organs, conditions and diseases. When a doctor says that a comatose patient has a left temporal lobe epidural hematoma, the intention is to enlighten, not to obfuscate.\nIn the software profession, we have many efforts that have helped us develop terms to discuss software, faults, failures, attacks and vulnerabilities, such as the Common Weakness Enumeration (CWE) [1] and Landwehr et. al. Taxonomy of Computer Program Security Flaws [2], but much work remains. We want to more accurately and precisely define software bugs or vulnerabilities. Consider that including \u0026ldquo;canary\u0026rdquo; values around arrays detects some buffer overflows while using address layout randomization mitigates other buffer overflows. A precise, orthogonal classification can state exactly which cases of buffer overflows each approach handles. We can also clearly state the classes of bugs that a tool can find and more easily determine if two tools generally find the same set of bugs or if they find different, complimentary sets.\nThrough centuries of experimentation and development of scientific principles, we now have the Periodic Table of Elements. Just as the structure of the periodic table reflects the underlying atomic structure, we are developing a taxonomy dictated by the \u0026ldquo;natural\u0026rdquo; organization of software bugs, while using as stepping stones known bugs enumerations, compendia and collections. For this and other analogies on what we are embarking on, we recall below some well-know organizational structures in science.\nScience has developed many different organizational structures. For example, the Periodic Table of Elements, the recently rearranged Tree of Life, the Geographic Coordinate System, and the Dewey Decimal Classification System.\nMendeleev\u0026rsquo;s Periodic Table\r#\rHowever obvious the Mendeleev\u0026rsquo;s Periodic Table seems today, it required extensive thought and investigation:\nGreeks used element and atom to name differences between materials and smallest parts of matter. In 330 BC, Aristotle proposed that everything is a mixture of \u0026ldquo;root elements\u0026rdquo;: Earth, Fire, Air, Water. Aristotle's Root Elements (Source: Reich Chemistry)\nIn the Middle Ages, alchemists made lists of materials, such as alcohol, sulfur, mercury, and salt.\nLavoisier created a list of 33 elements - e.g. oxygen, nitrogen, hydrogen, phosphorus, mercury, zinc, sulfur, light, and caloric, and distinguished metals from non-metals.\nDalton realized \u0026quot; atoms of same element are identical in all respects, particularly weight.\u0026quot;\nIn 1800s, several tables of elements were developed:\nDe Chancourtois first noticed periodicity of elements.When ordered by their atomic weights, similar elements occur at regular intervals.\nMendeleev\u0026rsquo;s Periodic Table in 1869 and his forecast of properties of missing elements reflected the century of growth in knowledge that reflects atomic structure: Columns correspond to the number of electrons in the outer shell and the fundamental chemical properties. Rows correspond to the number of electron shells.\nDiscovery of Chemical Elements - click on image for detailed view (Source: Wikimedia Commons)\nTree of Life\r#\rDiscoveries of more than 1,000 new types of bacteria and Archaea over the past 15 years have dramatically rejiggered the Tree of Life to account for these microscopic life forms. The new Tree of Life divides life into three domains: Bacteria, Archaea and Eukaryotes. It clearly shows that \u0026ldquo;life we see around us - plants, animals, humans and other so-called eukaryotes - represent a tiny percentage of the world\u0026rsquo;s biodiversity.\u0026rdquo;\nThe Tree of Life - click on image for detailed view (Source: Berkeley)\nGeographic Coordinate System\r#\rThe Geographic Coordinate System allows to specify any location on the Earth using Latitude, Longitude and Elevation. Longitude lines are perpendicular and latitude lines are parallel to the equator. Geographic Coordinate System (Source: Wikipedia) Dewey Decimal Classification System\r#\rThe Dewey Decimal Classification System allows new books and whole new subjects to be placed in reasonable locations in a library, for easy retrieval based on subject.\nCategories of Dewey Decimal Classification System. (Source: Appleton)\nReferences\r#\r[1] The MITRE Corporation. Common Weakness Enumeration (CWE).\n[2] C. E. Landwehr, A. R. Bull, J. P. McDermott, and W. S. Choi. A taxonomy of computer program security flaws, and examples. ACM Computing Surveys. vol. 26. no. 3. pp. 211-254. September 1994.\n"},{"id":2,"href":"/BF/Old/Classes/BOF/","title":"BOF","section":"Classes","content":"\rBuffer Overflow (BOF) Class\r#\rDefinition\r#\rWe define Buffer Overflow (BOF) as:\nThe software accesses through an array a memory location that is outside the boundaries of that array. [1]\nOften referred to as a \u0026ldquo;buffer,\u0026rdquo; an array is a contiguously allocated set of objects [1], called elements. An array has a definite size, that is, a definite number of elements are allocated to it. The software should not use the array name to access anything outside the boundary of the allocated elements. The elements are all of the same data type and are accessed by integer offsets.\nIf the software can utilize the array name (more generally, array handle) to access any memory other than the allocated objects, it falls into this class.\nType\r#\rLow-level (language related).\nTaxonomy\r#\rFig. 1 depicts BOF causes, attributes and consequences.\nFig 1. Buffer Overflow (BOF) Class - click on image for detailed view.\nAttributes\r#\rAccess – Read, Write.\nThis is the access operation causing buffer overflow.\nBoundary – Below, Above.\nThis indicated which end of the array is violated.\nLocation - Heap, Stack.\nThis indicates what part of memory the array is allocated in.\nMagnitude - Small, Moderate, Far.\nThis indicates how far outside the boundary the violation extends – one to a few bytes; eight to dozens bytes; or hundreds, thousands or more bytes.\nData Size - Little, Some, Huge.\nThis indicates how much data is accessed beyond the boundary.\nExcursion - Continuous, Discrete.\nThis indicates whether the violating access was preceded by consecutive accesses of elements within the array (continuous) or the violation was just accessing outside of the array (discrete).\nAny of the attributes may be \u0026ldquo;any,\u0026rdquo; \u0026ldquo;don\u0026rsquo;t care\u0026rdquo; or \u0026ldquo;unknown.\u0026rdquo; For example, strict bounds checking is equally effective regardless of the location, magnitude, data size or excursion of the violation. Keeping return addresses in a separate stack helps prevent problems occurring from write accesses when the array location is the stack.\nCauses\r#\rIn the graph of causes, Data Exceeds Array may be caused by an Input [that is] Not Checked Properly or by an Incorrect Calculation. The specific cases of Data Exceeds Array are Array Too Small and Too Much Data. Too Much Data may be caused by No NULL Termination. Wrong Index [or] Pointer Out of Range may be caused by Incorrect Calculation, too, or by an Incorrect Conversion.\nThe specific cases of Incorrect Calculation are Missing Factor, Incorrect Argument, Off By One, Integer Coercion, Integer Overflow, Wrap-around and Integer Underflow.\nArray Too Small indicates the array was allocated smaller than it should have been. This may occur because the programmer leaves out a factor, like the size of a header, uses the wrong variable, or forgets room for a null to terminate a string.\nToo Much Data indicates more data is accessed than was anticipated. This may occur because the string is not NULL terminated or the amount of data is calculated differently than the size of the buffer (e.g. Heartbleed).\nExposition: When we examine code, we can say in some cases that the programmer allocated the array too small, such as in CVE-2015-0235 - Ghost. The code computes the size of a buffer needed, but leaves out one factor, which makes the buffer four bytes short. In other cases, too much data was accessed, such as in CVE-2014-0160 - Heartbleed. A string was stored in an array, but instead of computing the length of the string, the code used a length from the input, which was not checked against the string. This can cause the code to read far more from the buffer than was allocated. In both cases, the size of the data exceeds the size of the array. Just looking at the code, it may be difficult to determine which case it is - it needs semantic content. That\u0026rsquo;s why the two are sub-causes of one cause.\nConsequences\r#\rThe graph of consequences shows what could happen due to the fault. Resource Exhaustion refers to Memory and CPU.\nSites\r#\rBOF may occur at the use of [ ] or the use of unary * operator with arrays in the C language. Sites also include the use of many string library functions, such as strcpy() or strcat().\nRelated BF Classes\r#\rBF classes related to BOF are: IEX, ATN, \u0026lt;\u0026lt;content to be added\u0026gt;\u0026gt;.\nRelated CWEs and SFP\r#\rCWEs related to BOF are CWE-118, CWE-119, CWE-120, CWE-121, CWE-122, CWE-123, CWE-124, CWE-125, CWE-126, CWE-127, CWE-129, CWE-680, CWE-786, CWE-787, CWE-788, CWE-823.\nBF BOF description of these CWEs are provided here.\nThe only related SFP cluster is SFP8 Faulty Buffer Access under Primary Cluster: Memory Access.\nBF Descriptions of BOF Related CWEs are provided here.\nApplication\r#\rApplication examples are provided here.\nReferences\r#\r[1] I. Bojanova, P. E. Black, Y. Yesha, and Y. Wu, “The Bugs Framework (BF): A Structured approach to express bugs”, Proceedings of IEEE International Conference on Software Quality, Reliability and Security (QRS), 2016, , pp. 175-182.\n[2] Information Technology \u0026ndash; Programming Languages – C”, ISO/IEC 9899:2011. Committee Draft-April 12, 2011 N1570, The International Organization for Standardization and the International Electrotechnical Commission (ISO/IEC) Joint Technical Committee JTC 1, Information technology, Subcommittee SC 22, Programming languages, their environments and system software interfaces. Working Group WG 14 - C. Tech. Rep. 2011.\n"},{"id":3,"href":"/BF/Old/Examples/BOF/","title":"BOF","section":"Examples","content":"\rBuffer Overflow (BOF) Examples\r#\rCVE-2014-0160 (Heartbleed) BF Taxonomy Cause: Input not checked properly leads to Data Exceeds Array (specifically Too Much Data) Attributes: Access: Read Boundary: Above Location: Heap Data Size: Huge Excursion: Continuous Consequence: IEX (if not had been cleared - CWE-226) BF Description \"Input not checked properly leads to too much data, where huge data is read from the heap in a continuous excursion above the array boundary, which may be exploited for IEX (if not had been cleared).\" [2] CVE Description \"The (1) TLS and (2) DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to d1_both.c and t1_lib.c, aka the Heartbleed bug.\" [1] Analysis The following analysis is based on information in [1,3,4,5]. A user has to send to the software data, and a number called payload that is the length of that data. The software has to send the data received back to the user. In the Heartbleed attack, a malicious user gives payload a value that can be as large as 65535+1+2+16, and sends data having a number of bytes that is much less than payload, and can be as small as 1. The software stores that data in an array that it allocated for that purpose. The size of that array is much less than 65535+1+2+16. The software does not check the data and the value of payload in order to make sure that the number of bytes of data is equal to payload. The software therefore assumes that those numbers are equal. The software reads, using memcpy, payload consecutive bytes from that array, beginning at its first byte, (continuous excursion) and sends them to the malicious user. This results in reading a large number of bytes beyond the end of the allocated array. The software did not clear the memory that it read from beyond the allocated array. Therefore, the data read and sent to the malicious user by the software includes sensitive information. Source Code Code With Bug 1 2 3 4\n5\n6\n7\n8 hbtype = *p++;\nn2s(p, payload);\npl = p;\nCode With Fix 1 2 3 4 5 6 7 8 /* Read type and payload length first */\nif (1 +2 + 16 \u003e s-\u003es3-\u003errec.length)\n\u0026nbsp;return 0; /* silently discard */\nhbtype = *p++;\nn2s(p, payload);\nif (1 + 2 + payload + 16 \u003e s-\u003es3-\u003errec.length)\n\u0026nbsp;return 0; /* silently discard per RFC 6520 sec. 4 */\npl = p; "},{"id":4,"href":"/BF/BF-CVE-Descriptions/CVE-2001-1141/","title":"CVE-2001-1141","section":"Examples","content":"\rCVE-2001-1141\r#\rBF Taxonomy Cause: Improper PRNG Algorithm (C md_rand - the secret PRNG state is updated with portion, as small as on byte, of the PRNG's previous output, which is not secret) Attributes: Function: Mixing (back into entropy pool) Algorithm: Hash Function ( SHA-1 used for PRNG output and to update its internal secret state) Used For: Generation (of cryptographic keying material - nonces, cryptographic keys) Pseudo-Randomness Requirement: Sufficicent Space Size and Unpredictability (can be predicted from previous value through brute force) Consequence: KMN\u003eGenerate with IEX of future keying BF Description Use of improper PRNG algorithm (C md_rand uses SHA-1 for mixing back in the entropy pool portion, as small as one byte, of previous output to update PRNG’s state), allows generation of cryptographic keying material (nonces and cryptographic keys) that does not satisfy the sufficient space size and unpredictability (can be predicted from previous values through brute force) pseudo-randomness requirements, which leads to KMN\u003eGenerate and IEX of future keying material. Analysis A PRNG used for cryptography does not satisfy the requirement of unpredictability from previous values, because the internal state can be determined from number of output requests. Possible consequences include: IEX of future PRNG output (CVE-2001-1141) (which is KMN\u003eGeneration failure) and weak encryption, confidentiality compromise (which is ENC\u003eConfidentiality failure). The entropy accumulation implementation (entropy pool and associated mixing function) allows reconstruction of the PRNG internal state . The mixing hash function for md (in the C md_rand) gets half of the previous value of md and bytes from the PRNG internal state. Wrongly, the half used is the one with the PRNG’s previous output (failed implementation relative to specification). Also, the number of used state bytes depends on the number of bytes requested as output, which could be as small as one byte. This enables a brute-force attack. The PRNG state could be reconstructed from the output of one large PRNG request (large enough to gain knowledge on md) followed by consecutive 1-byte PRNG requests. "},{"id":5,"href":"/BF/BF-CVE-Descriptions/CVE-2001-1585/","title":"CVE-2001-1585","section":"Examples","content":"\rCVE-2001-1585\r#\rBF Taxonomy Cause: Missing Verification Step (challenge-response) in public key authentication Attributes: Verified Data: Any Secret/Public Data State: Transferred (over network) Algorithm: Digital Signature (not using such allows private key not to be verified by public key) Security Service: Identity Authentication Consequence: IEX BF Description Missing verification step (challenge-response) in public key authentication allows private key for digital signature not to be verified by public key, which leads to identity authentication failure and may be exploited for IEX. [1] CVE Description \"SSH protocol 2 (aka SSH-2) public key authentication in the development snapshot of OpenSSH 2.3.1, available from 2001-01-18 through 2001-02-08, does not perform a challenge-response step to ensure that the client has the proper private key, which allows remote attackers to bypass authentication as other users by supplying a public key from that user's authorized_keys file.\" [2] Analysis The following analysis is based on information in [3, 4]: References [1] Bojanova, I., Black, P. E., Yesha, Y., Wu, Yan, Evans, Z., Poster: The Bugs Framework (BF) – First Classes: Buffer Overflow (BOF), Injection (INJ), Control of Interaction Frequency (CIF), STC 2017, NIST, Gaithersburg, MD, USA. [2] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2001-1585. [3] OpenBSD Security Advisory, Authentication By-Pass Vulnerability in OpenSSH-2.3.1. [4] S. Tatham, PuTTY User Manual – Chapter 8: \"Using public keys for SSH authentication.\" "},{"id":6,"href":"/BF/BF-CVE-Descriptions/CVE-2002-1697/","title":"CVE-2002-1697","section":"Examples","content":"\rCVE-2002-1697\r#\rBF Taxonomy Causes: Insecure mode of operation (ECB) leads to Weak Encryption Algorithm(for same shared key produces same ciphertext from same plaintext) Attributes: Sensitive Data: Any (Credentials, Cryptographic, ...) Data State: Transferred (over network) Algorithm: Symmetric (that allows identifying patterns and data recovery) Security Service: Confidentiality Consequence: IEX of Sensitive Data BF Description Use of insecure mode of operation (ECB) leads to weak symmetric encryption algorithm (for same shared key produces same ciphertext from same plaintext) that allows identifying patterns and recovery of transferred (over network) sensitive data, which is confidentiality failure and IEX of that sensitive data. [1] CVE Description \"Electronic Code Book (ECB) mode in VTun 2.0 through 2.5 uses a weak encryption algorithm that produces the same ciphertext from the same plaintext blocks, which could allow remote attackers to gain sensitive information.\" [2] Analysis The following analysis is based on information in [2, 3, 4]): The encryption algorithm uses XOR with a fixed key. Using a random one time pad with XOR would be fine, while reusing bits of a key with XOR results in weak encryption. References [1] The MITRE Corporation CVE-2002-1697. [2] Wikipedia, RSA (cryptosystem). [3] Seclists, Security weaknesses of VTun. [4] Wikipedia, Deterministic encryption. "},{"id":7,"href":"/BF/BF-CVE-Descriptions/CVE-2007-5460/","title":"CVE-2007-5460","section":"Examples","content":"\rCVE-2007-5460\r#\rBF Taxonomy Cause: Weak Encryption Algorithm (XOR xipher with fixed key) Attributes: Sensitive Data: Credentials (PINs/passwords) Data State: Transferred (over network) Algorithm: Symmetric (that allows obtaining shared key, by sniffing or spoofing the docking process, and decryption) Security Service: Confidentiality Consequence: IEX of Sensitive Data credentials BF Description Use of weak encryption algorithm (XOR cipher with fixed key) allows obtaining the shared symmetric key (by sniffing or spoofing the docking process) and decryption of transferred (over network) credentials (PINs/passwords), which is confidentiality failure and IEX of sensitive data (PINs/passwords). [1] CVE Description \"Microsoft ActiveSync 4.1, as used in Windows Mobile 5.0, uses weak encryption (XOR obfuscation with a fixed key) when sending the user's PIN/Password over the USB connection from the host to the device, which might make it easier for attackers to decode a PIN/Password obtained by (1) sniffing or (2) spoofing the docking process.\" [2] Analysis The following analysis is based on information in [2, 3, 4]): Using electronic codebook (ECB) results in weak encryption, that is a case of deterministic encryption, where patterns in plaintext become evident in the ciphertext. References [1] Bojanova, I., Black, P. E., Yesha, Y., Wu, Yan, Evans, Z., Poster: The Bugs Framework (BF) – First Classes: Buffer Overflow (BOF), Injection (INJ), Control of Interaction Frequency (CIF), STC 2017, NIST, Gaithersburg, MD, USA. [2] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2007-5460. [3] BUGTRAQ:20071015 SYMSA-2007-010: Microsoft ActiveSync 4.x Weak Password Obfuscation. [4] Wikipedia, XOR cipher. "},{"id":8,"href":"/BF/BF-CVE-Descriptions/CVE-2008-0141/","title":"CVE-2008-0141","section":"Examples","content":"\rCVE-2008-0141\r#\rBF Taxonomy Cause: Inadequate Entropy Sources (current date/time and user name) Attributes: Function: Mixing Algorithm: Concatenation Used For: Generation (of password) Randomness Requirement: Non-Inferable (time known from password reset time, name - from user register) Consequence: IEX leading to ATN (Authentication Fault) BF Description Inadequate entropy sources (date/time and user name) mixing using concatenation allow generation of passwords that do not satisfy the non-inferable randomness requirement (time known from password reset time, name - from user register), which may be exploited for IEX (of password), leading to ATN "},{"id":9,"href":"/BF/BF-CVE-Descriptions/CVE-2008-4107/","title":"CVE-2008-4107","section":"Examples","content":"\rCVE-2008-4107\r#\rBF Taxonomy Cause: Improper PRNG Algorithms (not cryptographically strong PHP 5 rand and mt_rand) Attributes: Function: Generate (pseudo-random numbers) Algorithms: e.g., LCG or LSFR, Mersenne Twister Used For: Generation (of passwords) Pseudo-Randomness Requirement: Unpredictability/Indistinguishability and Prediction Resistance Consequence: IEX (of password), leading to ATN BF Description Improper PRNG algorithms (not cryptographically strong PHP 5 rand\u003e and mt_rand, based on algorithms such as LCG or LFSR, and Mersenne Twister) used to generate pseudo-random numbers, allow generation of passwords that do not satisfy the unpredictability/ indistinguishability and prediction resistance pseudo-randomness requirements and may be exploited for IEX of password, leading to ATN. Analysis PHP’s rand() usually uses LCG or LFSR, which is weak. PHP 5 mt_rand() uses Mersenne Twister, which is weak as well. It enables finding the internal state and all future values from 624 values. This vulnerability can be used for password guessing (CVE-2008-4107). "},{"id":10,"href":"/BF/BF-CVE-Descriptions/CVE-2014-0160/","title":"CVE-2014-0160","section":"Examples","content":"\rCVE-2014-0160 – Heartbleed Buffer Overflow\r#\rBF Taxonomy\r#\rFig 1. BF DVR bug from DVR–MAD–(MUS \u0026amp; MUS) chain of CVE-2014-0160 – Heartbleed Buffer Overflow - click on image for detailed view.\nDVR (Verify)\nCause: Improper Operation - Missing Attributes: Mechanism: Quantity Source Code: Codebase (d1_both.c and t1_lib.c) Execution Space: Admin State: Transferred (via network) Consequence: Improper Data - Inconsistent Value (size) Brief Description:\nHeartbleed is a vulnerability due to a bug in the OpenSSL that allows a server to read over the bounds of a buffer. Using the heartbeat extension tests in TLS (Transport Layer Security) and DTLS (Datagram Transport Layer Security) protocols, a user can send a heartbeat request to a server. The request contains a string and a payload unsigned integer, which value is expected to be the string size but could be as big as 65535.\nAnalysis\nFig. 1 presents the BF taxonomy for the Heartbeat DVR bug.\nThe Fix\nTo fix the bug, the OpenSSL team added a value verification for the array size.\n"},{"id":11,"href":"/BF/BF-CVE-Descriptions/CVE-2015-0204/","title":"CVE-2015-0204","section":"Examples","content":"\rCVE-2015-0204, 1637, 1067 (FREAK - Factoring attack on RSA-Export Keys)\r#\rBF Taxonomy An inner KMN leads to an inner ENC, which leads to an outer ENC. Inner KMN: Cause: Improper Offer of Weak Protocol (Export RSA – offered from MITM-tricked server and accepted by client) Attributes: Cryptographic Data: Keying Material (pair of private and public keys) Data State: Transferred (over network) Algorithm: Export RSA (512-bits key generation based on prime numbers, such that private key can be obtained from public key through factorization) Operation: Generate Consequence: IEX Keying Material (private key) Inner ENC: Causes: KMN Fault leads to Exposed Private Key Attributes: Sensitive Data: Cryptographic (Pre-Master Secret) Data State: Transferred (over network) Algorithm: Asymmetric (RSA) (that allows decryption of Pre-Master Secret using exposed private key and computation of Master Secret) Security Service: Confidentiality Consequence: IEX of Sensitive Data (Master Secret) Outer ENC: Causes: KMN Fault leads to Exposed Secret Key (Master Secret) Attributes: Sensitive Data: Credentials (passwords, credit cards) Data State: Transferred (over network) Algorithm: Symmetric (key is known) Security Service: Confidentiality Consequence: IEX of Sensitive Data (credentials) BF Description An inner KMN leads to an inner ENC, which leads to an outer ENC. Inner KMN: Improper offer of weak protocol (Export RSA from MITM-tricked server and accepted by client) allows use of 512-bits key generation (based on prime numbers) such that the private key can be obtained from the public key through factorization, which may be exploited for IEX of keying material (private key). Inner ENC: KMN fault leads to exposed private key for asymmetric encryption (RSA) that allows decryption of transferred (over network) cryptographic data (Pre-Master Secret) and computation of other cryptographic data (Master Secret), which is confidentiality failure and IEX of sensitive data (Master Secret). Outer ENC: KMN fault leads to exposed secret key (Master Secret) for symmetric encryption allows decryption of credentials (passwords, credit cards, etc.) transferred (over network), which is confidentiality failure and IEX of sensitive data (passwords, credit cards, etc.). [1] CVE Descriptions \"The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct RSA-to-EXPORT_RSA downgrade attacks and facilitate brute-force decryption by offering a weak ephemeral RSA key in a noncompliant role, related to the \"FREAK\" issue. NOTE: the scope of this CVE is only client code based on OpenSSL, not EXPORT_RSA issues associated with servers or other TLS implementations.\" [4] \"Schannel (aka Secure Channel) in Microsoft Windows Server 2003 SP2, Windows Vista SP2, Windows Server 2008 SP2 and R2 SP1, Windows 7 SP1, Windows 8, Windows 8.1, Windows Server 2012 Gold and R2, and Windows RT Gold and 8.1 does not properly restrict TLS state transitions, which makes it easier for remote attackers to conduct cipher-downgrade attacks to EXPORT_RSA ciphers via crafted TLS traffic, related to the \"FREAK\" issue, a different vulnerability than CVE-2015-0204 and CVE-2015-1067.\" [5] \"Secure Transport in Apple iOS before 8.2, Apple OS X through 10.10.2, and Apple TV before 7.1 does not properly restrict TLS state transitions, which makes it easier for remote attackers to conduct cipher-downgrade attacks to EXPORT_RSA ciphers via crafted TLS traffic, related to the \"FREAK\" issue, a different vulnerability than CVE-2015-0204 and CVE-2015-1637.\" [6] Analysis The following analysis is based on information in [7, 8, 9, 10]: The server offers a weak protocol (Export RSA) while the client requested strong protocol (RSA). Communication is encrypted by symmetric encryption. The key for that encryption (Master Secret) is created by both client and server from a Pre-Master Secret and nonces sent by client and server. The Pre-Master Secret is sent encrypted by RSA cryptosystem. The client requests RSA protocol, but man in the middle (MITM) intercepts and requests Export RSA that uses a 512 bit key. Factoring a 512 bit RSA key is feasible. Because of a bug, the client agrees to Export RSA. MITM factors the public 512 bit public RSA key, uses this factoring to recover the private RSA key, and then uses that private key to decrypt the Pre-Master Secret. Then it uses the Pre-Master Secret and the nonces to generate the Master Secret. The Master Secret enables MITM to decrypt the encrypted communication from that point on. Source Code FREAK Client Code With Bug 1 2 3 4 5 6 7 8 9 10 11 12 13 #ifndef OPENSSL_NO_RSA if (alg_k \u0026amp; SSL_kRSA) { if ((rsa=RSA_new()) == NULL) { SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE); FREAK Client Code With Fix 1 2 3 4 5 6 7 8 9 10 11 12 13 #ifndef OPENSSL_NO_RSA if (alg_k \u0026amp; SSL_kRSA) { /* Temporary RSA keys only allowed in export ciphersuites */ if (!SSL_C_IS_EXPORT(s-\u0026gt;s3-\u0026gt;tmp.new_cipher)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNEXPECTED_MESSAGE); goto f_err; } if ((rsa=RSA_new()) == NULL) { SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE); FREAK Server Code With Bug 1 2 3 4 5 6 7 8 9 10 11 12 13 14 case SSL3_ST_SW_KEY_EXCH_B: alg_k = s-\u0026gt;s3-\u0026gt;tmp.new_cipher-\u0026gt;algorithm_mkey; /* clear this, it may get reset by send_server_key_exchange */ if ((s-\u0026gt;options \u0026amp; SSL_OP_EPHEMERAL_RSA) #ifndef OPENSSL_NO_KRB5 \u0026amp;\u0026amp; !(alg_k \u0026amp; SSL_kKRB5) #endif /* OPENSSL_NO_KRB5 */) /* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key even when forbidden * by protocol specs (handshake may fail as clients are not required to * be able to handle this) */ s-\u0026gt;s3-\u0026gt;tmp.use_rsa_tmp=1; else s-\u0026gt;s3-\u0026gt;tmp.use_rsa_tmp=0; if (s-\u003es3-\u003etmp.use_rsa_tmp FREAK Server Code With Fix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 case SSL3_ST_SW_KEY_EXCH_B: alg_k = s-\u0026gt;s3-\u0026gt;tmp.new_cipher-\u0026gt;algorithm_mkey; /* clear this, it may get reset by send_server_key_exchange */ s-\u0026gt;s3-\u0026gt;tmp.use_rsa_tmp=0; if ( References [1] Bojanova, I., Black, P. E., Yesha, Y., Wu, Yan, Evans, Z., Poster: The Bugs Framework (BF) – First Classes: Buffer Overflow (BOF), Injection (INJ), Control of Interaction Frequency (CIF), STC 2017, NIST, Gaithersburg, MD, USA. [2] The MITRE Corporation, CVE-2016-1919. [3] openwall.net, [CVE-2016-1919] \"Weak eCryptFS Key generation from user password.\" [4] The MITRE Corporation, CVE-2015-0204. [5] The MITRE Corporation, CVE-2015-1637. [6] The MITRE Corporation, CVE-2015-1067. [7] R. Heaton, \"The SSL FREAK vulnerability explained.\" [8] Censys, The FREAK Attack. [9] StackExchange, Protecting phone from the FREAK bug. [10] GitHub, openssl, Only allow ephemeral RSA keys in export ciphersuites. "},{"id":12,"href":"/BF/BF-CVE-Descriptions/CVE-2015-2141/","title":"CVE-2015-2141","section":"Examples","content":"\rCVE-2015-2141\r#\rBF Taxonomy Cause: Modification of Verification Algorithm by adding a step (blinding) Attributes: Verified Data: Any Secret/Public Data State: Transferred (over network) Algorithm: Digital Signature (Rabin-Williams) (that allows obtaining the private key in cases of incorrect unblinding) Security Service: Identity Authentication Consequence: IEX BF Description Modification of verification algorithm (digital signature, Rabin-Williams) by adding a step (blinding before signing) allows obtaining the private key in cases of incorrect unblinding, which leads to identity authentication failure and may be exploited for IEX. [1] CVE Description \"The InvertibleRWFunction::CalculateInverse function in rw.cpp in libcrypt++ 5.6.2 does not properly blind private key operations for the Rabin-Williams digital signature algorithm, which allows remote attackers to obtain private keys via a timing attack.\" [5] Analysis The following analysis is based on information in [6, 7]: Having the private key allows an attacker to be authenticated as the owner of that key. The software intends to use blinding to defend against a timing attack, as follows: Instead of signing the data directly, the data is first transformed using a secret random value (blinding) and then is digitally signed using a private key. At the end, the effect is removed (unblinding), so that there is signed data as if no transformation took place. See [6, 7] for blinding used for RSA. The flaw in this CVE is in doing blinding/ unblinding incorrectly, so that in some cases the effect of the transformation is not removed from the data. This enables the attacker to use the transformed data to recover the private key using a mathematical calculation as described in [6]. In [6] it is observed that if the secret random integer used to transform the message is a quadratic residue modulo an appropriate integer, then the unblinding step correctly undoes the transformation. The fix in [20] assures that the integer is such a quadratic residue. Source Code Code With Bug 1 2 3 4 5 6 7 8 9 10 11 DoQuickSanityCheck(); ModularArithmetic modn(m_n); Integer r, rInv; do {// do this in a loop for people using small numbers for testing r.Randomize(rng, Integer::One(), m_n - Integer::One()); rInv = modn.MultiplicativeInverse(r); } while (rInv.IsZero()); Integer re = modn.Square(r); re = modn.Multiply(re, x);\t// blind Code With Fix 1 2 3 4 5 6 7 8 9 10 11 DoQuickSanityCheck(); ModularArithmetic modn(m_n); Integer r, rInv; do {// do this in a loop for people using small numbers for testing r.Randomize(rng, Integer::One(), m_n - Integer::One()); // Squaring to satisfy Jacobi requirements suggested by JPM. r = modn.Square(r); rInv = modn.MultiplicativeInverse(r); } while (rInv.IsZero()); Integer re = modn.Square(r); re = modn.Multiply(re, x);\t// blind References [1] Bojanova, I., Black, P. E., Yesha, Y., Wu, Yan, Evans, Z., Poster: The Bugs Framework (BF) – First Classes: Buffer Overflow (BOF), Injection (INJ), Control of Interaction Frequency (CIF), STC 2017, NIST, Gaithersburg, MD, USA. [2] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2001-1585. [3] OpenBSD Security Advisory, Authentication By-Pass Vulnerability in OpenSSH-2.3.1. [4] S. Tatham, PuTTY User Manual – Chapter 8: \"Using public keys for SSH authentication.\" [5] The MITRE Corporation, CVE-2015-2141. [6] Bugzilla – Bug 936435, VUL-0: CVE-2015-2141: libcryptopp: libcrypto++ -- security update. [7] E. Sidorov, \"Breaking the Rabin-Williams digital signature system implementation in the Crypto++ library.\" [8] Wikipedia, Blinding Cryptography. [9] Github, Fix for CVE-2015-2141. "},{"id":13,"href":"/BF/BF-CVE-Descriptions/CVE-2016-1919/","title":"CVE-2016-1919","section":"Examples","content":"\rCVE-2016-1919\r#\rBF Taxonomy To be added. BF Description A KMN leads to an ENC. KMN: Use of weak algorithm (eCryptFS-key from password and stored TIMA key) allows generation of keying material (secret key) that can be obtained through brute force, which may be exploited for IEX of keying material (secret key). ENC: KMN fault leads to exposed secret key that allows decryption of stored (on disk) sensitive data, which is confidentiality failure and may be exploited for IEX of sensitive data. [1] CVE Description \"Samsung KNOX 1.0 uses a weak eCryptFS Key generation algorithm, which makes it easier for local users to obtain sensitive information by leveraging knowledge of the TIMA key and a brute-force attack.\" [2] Analysis The following analysis is based on information in [3]: The TIMA key is a random stored byte string. The secret key used is obtained by XOR of the TIMA key and the password characters, where the minimum password length is 7. However, if the password length is no more than 8, a base 64 expansion results in a key that does not depend on the password. The TIMA key is stored, and for a known TIMA key, the key is known, or, if the password length slightly exceeds 8, there is a small set of possible keys. The TIMA key can be obtained using a preliminary step. References [1] Bojanova, I., Black, P. E., Yesha, Y., Wu, Yan, Evans, Z., Poster: The Bugs Framework (BF) – First Classes: Buffer Overflow (BOF), Injection (INJ), Control of Interaction Frequency (CIF), STC 2017, NIST, Gaithersburg, MD, USA. [2] The MITRE Corporation, CVE-2016-1919. [3] openwall.net, [CVE-2016-1919] \"Weak eCryptFS Key generation from user password.\" "},{"id":14,"href":"/BF/BF-CVE-Descriptions/CVE-2018-20991/","title":"CVE-2018-20991","section":"Examples","content":"\rCVE-2018-20991 - Rust SmallVec Iterator Panic\r#\rBF Taxonomy\r#\rFig 1. BF for CVE-2018-20991 – Rust Iterator Panic - click on image for detailed view.\nMUS (Deallocate)\nCause: Improper Pointer - Dangling Pointer (to SmallVec) Attributes: Mechanism: Explicit Source Code: Standard Library (lib.rs) Execution Space: Userland Object Ownership: Shared Object Location: Heap Consequence: Memory Error - Double Free Fig 2. BF for the Bug in the Fix of CVE-2018-20991 - click on image for detailed view.\nMUS (Deallocate)\nCause: Improper Pointer - Wrong Sized Used (for SmallVec) Attributes: Mechanism: Explicit Source Code: Standard Library (lib.rs\u003e) Execution Space: Userland Object Ownership: Shared Object Location: Heap Consequence: Memory Error - Memory Leak BF Description:\nRust is a multi-paradigm programming language focused on safe concurrency. It has a similar syntax to C++ and offers features to deal with dynamic memory allocation, such as smart pointers. In general, a Rust programmer does not need to keep track of memory allocation and deallocation, as the language is designed to be memory safe this way.\nCVE Description\nAnalysis\nThe versions before Rust 0.6.3 have a bug in the lib.rs file. The insert_many() method in the SmallVec class has two parameters: an iterable I and an index. The method inserts all elements in the iterable I at position index, shifting all the following elements backwards. In the SmallVec class, if an iterator passed to SmallVec::insert_many() panics in Iterator::next, the destructor is called while the vector is in an inconsistent state, possibly causing double free (deallocation via references to same object).\n"},{"id":15,"href":"/BF/BF-CVE-Descriptions/CVE-2019-10748/","title":"CVE-2019-10748","section":"Examples","content":"\rCVE-2019-10748 – Sequelize SQL Injection\r#\rBF Taxonomy\r#\rFig 1. BF for CVE-2019-10748 – Sequelize SQL Injection - click on image for detailed view.\nDVL (Sanitize)\nCause: Improper Operation - Missing Attributes: Mechanism: Format Source Code: Codebase (query-generator.js) Execution Space: Local State: Transferred (via network) Object Location: Heap Consequence: Injection Error - Query Injection (SQL Injection) Brief Description:\nSequelize is an Object-Relational Mapper for Node.js. It supports Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server; it facilitates transaction support, relations, and lazy loading. In several versions query-generator.js allows SQL injection.\nAnalysis\nUser input path is not sanitized for MySQL/MariaDB syntax in a JSON (JavaScript Object Notation) object.\nThe Fix\nTo fix the bug, the developers check the input paths syntax and sanitize it.\n"},{"id":16,"href":"/BF/BF-CVE-Descriptions/CVE-2020-5902/","title":"CVE-2020-5902","section":"Examples","content":"\rCVE-2020-5902 – BIG-IP TMUI RCE\r#\rBF Taxonomy\r#\rFig 1. BF for CVE-2020-5902 – BIG-IP TMUI RCE - click on image for detailed view.\nDVL (Validate)\nCause: Improper Operation - Missing Attributes: Mechanism: Format (e.g., via “.*\\.\\.;.*“ regular expression) Source Code: Codebase (login.jsp) Execution Space: Admin State: Transferred (via network) Consequence: Injection Error - File Injection (Path Traversal) Brief Description:\nBIG-IP is a family of server-side products from F5 Inc. focused on availability, performance, and security. In several versions, its Traffic Management Interface (TMUI), known as the BIG-IP Configuration utility, allows Remote Code Execution (RCE).\nAnalysis\nTMUI of BIG-IP accepts /..;/ via the login interface /tmui/login.jsp. However, the Apache Tomcat treats /..;/ as /../, which is a relative path for going one directory up. This allows a malicious user to bypass authentication, save and open files, and run arbitrary commands on the host.\nThe Fix\nTo fix the bug, input validation (e.g., via the ”.*\\.\\.;.*” regular expression) should be added to reject any /..;/ elements.\n"},{"id":17,"href":"/BF/BF-CVE-Descriptions/CVE-2021-21834/","title":"CVE-2021-21834","section":"Examples","content":"\rCVE-2021-21834 - Bad Allocation Chain\r#\rBF Taxonomy\r#\rFig 1. BF for CVE-2021-21834. - click on image for detailed view.\nDVR (Verify)\nCause: Improper Operation - Missing Attributes: Mechanism: Range Source Code: Third Party (Library box_code_base.c) Execution Space: Local Data State: Stored(“number of entries” read from file) Consequence: Improper Data Value - Inconsistent Value ( \u003e max 64-bit int ) TCM (Calculate)\nCause: Improper Data Value - Wrong Argument Value Attributes: Mechanism: Operator(Arithmetic: ‘*’) Source Code: Third Party (Library box_code_base.c) Data Value Kind: Numeric Data Type Kind: Structured Consequence: Improper Data Value - Wrap Around MAL (Allocate)\nCause: Improper Data Value - Wrong Size Used (size of memory to allocate Attributes: Mechanism: Explicit Source Code: Third Party (Library box_code_base.c) Execution Space: Userland Ownership: Single Location: Heap Consequence: Improper Object Size - Not Enough Memory Allocated MAD (Reposition)\nCause: Improper Object Size - Not Enough Memory Allocated Attributes: Mechanism: Sequential Source Code: Third Party (Library box_code_base.c) Execution Space: Userland Location: Heap Consequence: Improper Data Value - Over Bounds Pointer MUS (Write)\nCause: Improper Data Value - Over Bounds Pointer Attributes: Mechanism: Sequential Source Code: Third Party (Library box_code_base.c) Execution Space: Userland Span: Huge Location: Heap Consequence: Memory Overflow - Buffer Overflow BF Description:\nThe GPAC Project on Advanced Content is a C language implementation of the MPEG- 4 audio/video compression standard. In version 1.0.1, the library is vulnerable to decoding a specially crafted MPEG-4 input file.\nCVE Description\nAnalysis The library code reads the “number of entries” value from a file into a 32-bit integer object (ptr−→nb_entries) and checks if it is not larger than the 64- bits input size (ptr−→size/8). Then, the size of memory that should be allocated is calculated by multiplying the “number of entries” by the size of a u64 object (sizeof(u64)), which can result in an integer overflow on a 32-bit platform. When such an overflowed integer is used, the allocation routine will create an undersized buffer, which will be populated based on its larger actual size, leading to a buffer overflow. Fig.10 presents the BF taxonomy for this vulnerability. The Fix To fix the bug, the GPAC team checked the maximum integer size ((u64)ptr−→nb_entries \u003e (u64)SIZE_MAX/sizeof(u64)), fixing the DVR bug and resolving the entire vulnerability. "},{"id":18,"href":"/BF/BF-CVE-Descriptions/CVE-2021-23440/","title":"CVE-2021-23440","section":"Examples","content":"\rCVE-2021-23440 - Type Mismatch bypassing Input Validation\r#\rBF Taxonomy\r#\rFig 1. First BF chain: Loose comparison misuse. - click on image for detailed view.\nTCM (Evaluate)\nCause: Improper Operation - Wrong Attributes: Mechanism: Operator Source Code: Codebase Data Value Kind: Boolean Data Type Kind: Structured Consequence: Improper Data Value - Wrong Result Fig 2. Second BF chain: Conversion missing before loose comparison. - click on image for detailed view.\nTCV (Cast)\nCause: Improper Operation - Missing Attributes: Mechanism: Pass In Source Code: Codebase Data Value Kind: Text Data Type Kind: Structured Consequence: Improper DataType - Wrong Type ( nested list with [‘_proto_’’] instead of string value DVL (Validate)\nCause: Improper Data - Tampered Data ( nested list with[‘_proto_’’] ) Attributes: Mechanism: Safelist Source Code: Codebase Execution Space: Local/attribute\u003e Data State: Entered Consequence: Injection Error - Command Injection BF Description:\nThe package set-value for JavaScript is vulnerable to prototype pollution in versions \u0026lt;2.0.1, \u003e=3.0.0, \u0026lt;4.0.1. It happens due to a type mismatch in the prototype pollution verification.\nCVE Description\nAnalysis This vulnerability has two possible BF chains. The first chain is: the loose comparison operator is misused. The second chain is: a type conversion is missing before using the loose comparison, leading to improper input validation and prototype pollution, a kind of command injection in JavaScript. The Fix There are two ways of fixing this vulnerability: the developers could use strict comparison, solving the TCM bug, or they could do a type conversion before the loose comparison. They chose the latter. "},{"id":19,"href":"/BF/BF-CVE-Descriptions/CWE-468/","title":"CWE-468","section":"Examples","content":"\rCWE-468 - Incorrect Pointer Scaling\r#\rBF Taxonomy\r#\rFig 1. BF for CWE-468. - click on image for detailed view.\nTCV (Cast)\nCause: Improper Operation - Wrong Attributes: Mechanism: Pass In Source Code: Codebase Data Value Kind: Pointer Data Type Kind: Primitive Consequence: Improper Data Type - Wrong Type ( int instead of char ) NRS (Call)\nCause: Improper Data Type - Wrong Argument Type Attributes: Mechanism: Ad-hoc Bind Source Code: Codebase Entity: Function Data Type Kind: Primitive Consequence: Improper Function - Wrong Overloaded Function Bound ( +(int*,int) instead of +(char*,int) ) TCM (Calculate)\nCause: Improper Function - Wrong Overloaded Function Attributes: Mechanism: Operator Source Code: Codebase Data Value Kind: Pointer Data Type Kind: Primitive Consequence: Improper Data Value - Wrong Result ( Pointer position ) MAD (Reposition)\nCause: Improper Data Value - Wrong Index Attributes: Mechanism: Direct Source Code: Codebase Execution Space: Userland Location: Stack Consequence: Improper Object Address - Over Bounds Pointer MUS (Read)\nCause: Improper Object Address - Over Bounds Pointer Attributes: Mechanism: Direct Source Code: Codebase Execution Space: Userland Span: Little Location: Stack Consequence: Memory Overflow - Buffer Overflow BF Description:\nCVE Description\nAnalysis The chain starts with an improper casting of the pointer p to char * that leads to invocation of a wrong addition operator *int + 16 instead of *char + 1. Therefore, the pointer moves 4 bytes instead of 1 byte (3 bytes off), reading the wrong value, outside the object x (buffer overflow). Fig.11 presents the BF taxonomy for this weakness. The Fix To fix the bug, the programmer should first cast and then add: int *p = x; char * second_char = (char *)p + 1; "},{"id":20,"href":"/BF/BF-Classes/_CRY/Model/","title":"Model","section":"Cryptographic Store and Transfer Bugs","content":"\rBF Model of Cryptographic Store or Transfer\r#\rCryptography\r#\rCryptography is a broad, complex, and subtle area. It incorporates many clearly separate processes, such as encryption/decryption, verification of data or source, and key management. There are bugs if the software does not properly transform data into unintelligible form, verify authenticity or correctness, manage keys, or perform other related operations. Some transformations require keys, for example encryption and decryption, while others do not, for example secret sharing. Authenticity covers integrity of data, identity of data source, origin for non-repudiation, and content of secret sharing. Correctness is verified for uses such as zero-knowledge proofs. Cryptographic processes use particular algorithms to achieve particular security services.\nExamples of attacks are spoofing messages, brute force attack, replaying instructions, timing attack, chosen plaintext attack, chosen ciphertext attack, and exploiting use of weak or insecure keys.\nWe use cryptographic store or transfer to illustrate our ENC, VRF, and KMN classes of bugs. Note that these classes may appear in many other situations such as self-sovereign identities, block ciphers, and threshold cryptography. We focus on transfer (or store) because it is well known and it is what most people think of when \u0026ldquo;cryptography\u0026rdquo; is mentioned. We define bugs in cryptographic store or transfer as: The software does not properly encrypt/decrypt, verify, or manage keys for data to be securely stored or transferred.\nOur Model\r#\rA modern, secure, flexible cryptographic storage or transfer protocol likely involves subtle interaction between encryption, verification, and key management processes. It may involve multiple stages of agreeing on encryption algorithms, establishing public and private keys, creating session keys, and digitally signing texts for verification. Thus, encryption may use key management, which itself uses encryption and verification. The following figure presents a model of these recursive interactions and where potentially the corresponding ENC, VRF, KMN, and other BF bugs could happen. The rounded rectangles indicate the boundaries of the classes. The dashed ones show sending and receiving entities.\nOur Model of Cryptographic Store or Transfer Bugs. Encryption may occur in tandem with Verification or it may precede Verification serially, if the ciphertext is signed or hashed. Encryption uses Key Management, and Key Management likely uses Encryption and Verification to handle keys - click on image for detailed view.\nKMN is a class of bugs related to key management. Key management comprises key generation, selection, storage, retrieval and distribution, and determining and signaling when keys should be abandoned or replaced. A particular protocol may use any or all of these operations. Key management could be by a third party, the source, or the user - thus the KMN area intersects the Source and User areas. A third-party certificate authority (CA) distributes public keys in signed certificates. Key management often uses a recursive round of encryption and decryption, and verification to establish a shared secret key or session key before the actual plaintext is handled.\nENC is a class of bugs related to encryption and decryption. Encryption is by the source, decryption is by the user. The encryption/decryption algorithm may be symmetric, that is uses the same key for both, or asymmetric, which uses a pair of keys, one to encrypt and the other to decrypt. Public key cryptosystems are asymmetric. Ciphertext may be sent directly to the user, and verification accompanies it separately. The red line is a case where plaintext is signed or hashed and then encrypted.\nVRF is a class of bugs related to verification. Verification takes a key and either plaintext or ciphertext, signs or hashes it, then passes the result to the user. The user uses the same key or the other key from the key-pair to verify data integrity or source. Note that hash alone without any other mechanism cannot be used to verify source or to protect data integrity against attackers. However, it can be used to protect data integrity against channel errors.\nIn the cases of symmetric encryption, one secretly shared key (shKey) is used. The source encrypts with shKey, and the user decrypts also with shKey. In the cases of asymmetric encryption, pairs of mathematically related keys are used. The source pair is pbKeySrc and prKeySrc; the user pair is pbKeyUsr and prKeyUsr. The source encrypts with pbKeyUsr and signs with prKeySrc. The user decrypts with prKeyUsr and verifies with pbKeySrc.\n"},{"id":21,"href":"/BF/BF-Classes/_DAT/Model/","title":"Model","section":"Data Type Bugs","content":"\rBF Data Type Bugs Model\r#\rData Type bugs could be introduced at any of the declaration, name resolution, data type conversion, or data type related computation phases. Each data type related bug or weakness involves one data type operation: Declare, Define, Refer, Call, Cast, Coerce, Calculate, or Evaluate.\nThe BF Data Type Bugs model (Fig. 1) helped us identify the phases and the operations where such bugs could occur. The phases correspond to the BF Data Type Bugs classes: Declaration Bugs (DCL), Name Resolution (NRS), Type Conversion Bugs (TCV), and Type Computation Bugs (TCM). All data type operations are grouped by phase.\nThe operations under DCL (Fig. 1) are on declaring entities and on defining objects data and functions implementations: Declare and Define.\nThe operations under NRS (Fig. 1) are on resolving referred names and on binding their data types and the objects data, and on resolving called functions and binding their implementations: Refer and Call.The NRS operations are tied to the name resolution and binding that the Type System performs. Fig. 2 shows the corresponding sub-model. Note that the object data value is bound via the Initialize and Write operations of the BF Memory Use Bugs (MUS) class.\nThe operations under TCV (Fig. 1) are on explicit conversion and on implicit conversion into a different data type of a passed in/out of a function data value: Cast and Coerce.\nThe operations under TCM (Fig. 1) are on calculating an arithmetic operation (part of an algebraic expression) and on evaluating a boolean operation (part of a condition): Calculate and Evaluate.\nThe possible flow between operations from different phases is depicted with arrows in Fig. 1. A declared and defined entity is referred in source code via its name. Names, referred to in remote scopes, get resolved via resolved names- paces; resolved data types get bound to objects, functions, or generic data types according to their declarations (see the purple arrow flow). A resolved and bound object may be converted to another data type and used in computations as an argument or as a return of a called function, or to call a member function. A passed in argument is expected to be of the declared parameter data type and the passed out result is expected to be of the return data type. Otherwise, casting (explicit conversion) is expected before the call (see the blue arrows flow) or the value will get coerced (implicitly converted) to the parameter data type or the return data type, correspondingly (see the green arrows flow). Note that the green arrows flow is about passed in/out objects – it starts only from NRS Call, it never starts from DCL Declare. The presented operations flow helps in identifying possible chains of bugs and weaknesses.\nFig 1. The BF Data Type Bugs model. Comprises phases, corresponding to the BF classes DCL, NRS, TCV, and TCM. Shows the data type operations flow. - click on image for detailed view.\n"},{"id":22,"href":"/BF/BF-Classes/_INP/Model/","title":"Model","section":"Input/Output Check Bugs","content":"\rData Checks Bug Model\r#\rData should be checked to ensure proper results from its processing. It should adhere to object data types acceptable by the software. Bojanova and Galhardo, define an object as a piece of memory with well-defined size that is used to store primitive data or a data structure. As input, primitive data are checked and sanitized on string-of-characters level. A character – e.g., an ASCII (American Standard Code for Information Interchange) character – is a single symbol, such as an alphabet letter, a numeric digit, or a punctuation mark. Data structures in turn are built on primitive data but can also have a higher level of syntax and semantics rules.\nData check comprises data validation, where data syntax gets checked for being well-formed, and data verification, where data semantics gets verified for being accurate. The BF model separates data semantics check as data verification, although OWASP (Open Web Application Security Project) puts it under input validation.\nValidation is about accepting or rejecting data based on its syntax: it checks if data are in proper format (grammar). For example, checking if data consist of digits only or checking the syntax of an XML (Extensible Markup Language) document against a DTD (XML Document Type Definition) is data validation. Once data syntax is checked it may be sanitized. Sanitization is about neutralizing, filtering, or repairing data via escaping, removing, or adding symbols in data, correspondingly. An example of data sanitization would be removing a special character such as ’/’ or adding a closing parenthesis ’)’. The validate and sanitize operations use specific policies, such as to check against safelist, denylist, format (e.g., defined via regular expressions), or length. A safelist defines a set of known good content. A denylist defines a set of known bad content; it helps reject outright maliciously malformed data. Regular expressions define format patterns that data (viewed as strings) should match. They could be used for safelists and denylists.\nVerification is about accepting or rejecting data based on its semantics: it checks if data have proper value (meaning). For example, checking if a start date is before an end date, or checking the type of an XML document against a PowerPoint XSD (XML Schema Definition) is data verification. Once data semantics is checked, it may be corrected via assigning a new value or via removing data. An example of data correction would be setting the size to the buffer’s upper bound when the size that is supplied is larger than that upper bound. The verify and correct operations use specific policies to, for example, check data against a value (incl. NULL or list of values), quantity, range, type, or other business rules.\nData check bugs could be introduced at any of the data validation and data verification phases. Each bug or weakness involves one data check operation: validate, sanitize, verify, or correct. Each operation is over already-canonicalized1 data and the policy (the rules) against which it gets checked.\nThe BF Data Check Bugs model (Fig. 1) helped us identify the phases and the operations where such bugs could occur. The phases correspond to the BF Data Check Bugs classes: Data Validation Bugs (DVL) and Data Verification Bugs (DVR). All data check operations are grouped by phase.\nFig 1. The BF Data Check Bugs model. Comprises phases, corresponding to the BF classes DVL and DVR. Shows the data check operations flow. - click on image for detailed view.\nThe operations under DVL (Fig. 1) are on checking data syntax: Validate and Sanitize. The operations under DVR (Fig. 1) are on checking data semantics: Verify and Correct.\nThe possible flow between operations from different phases is depicted on Fig. 1 with arrows. Data could be validated and verified or only directly verified. The pre- sented operations flow helps in identifying possible chains of bugs/weaknesses.\n"},{"id":23,"href":"/BF/BF-Classes/_MEM/Model/","title":"Model","section":"Memory Bugs","content":"\rBF Memory Model\r#\rEach memory related bug or weakness involves one memory operation. Each operation is over a region of memory or over the address needed to reach it. That memory is used for storing data and has an important property: it is finite. It has boundaries and it has size. We call this piece of memory, with a well-defined size, an object. It is used to store a primitive data or a data structure. The memory address should be held by at least one _pointer_pointer or determined as an offset on the stack, otherwise the object will be unreachable. The object and the pointer are the operands of the memory operation.\nMemory bugs could be introduced at any of the phases of an object’s lifecycle: address formation, allocation, use, and deallocation. The BF Memory Bugs Model helps identify where in these phases bugs could occur (Fig. 1). The phases correspond to the BF memory bugs classes: Memory Addressing Bugs (MAD), Memory Allocation Bugs (MAL), Memory Use Bugs (MUS), and Memory Deallocation Bugs (MDL). All possible memory operations are grouped by phase. The presented operations flow helps in identifying possible chains of bugs/weaknesses.\nThe operations under MAD (Fig. 1) are on forming or modifying a pointer: Initialize, Reposition, and Reassign. Bugs in pointer initialization could result in pointers to meaningless objects. Moving a pointer via a bugged Reposition could get it pointing outside the object bounds. Bugs in Reassign could connect a pointer to a wrong object.\nThe operations under MUS are on reading or writing the content of an object through one of its pointers: Initialize, Read, Write, Clear, and Dereference. Bugs in object initial- ization could lead to use of random or malicious data. Bugs in write could alter data wrongly. Bugs in Clear could leak confidential information such as passwords and cryptographic private keys. Bugs in Dereference are practically unsuccessful reading or unsuccessful writing.\nThe operations under MAL are on creating an object or extending it through one of its pointers: Allocate, Extend, and Reallocate–Extend.The operations under MDL are on destroying or reducing an object through one of its pointer: Deallocate, Reduce, and Reallocate–Reduce. Both MAL and MDL operations affect the boundaries and the size of the object. Bugs in Reallocate may concern multiple pointers to the same object. Allocation in excess or failure to deallocate unused objects could exhaust memory. Excessive reduction of allocated memory could lead to an object that is too little for the data it needs to store.\nThe possible flow between operations from different phases is depicted on Fig. 1 with colored arrows: blue is for the main flow; green is for allocation requested at a specific address; red is for the extra flow in case of reallocation.\nFollowing the blue arrows, the very first operation is MAL Allocate an object. Following the green arrows, the first operation is MAD Initialize a pointer. Next operation, following the blue arrows, should be MAD Initialize the pointer to the address returned by Allocate. While, following the green arrows, next operation should be MAL Allocate an object at the address the pointer holds.\nAfter an object is allocated and its pointer is initialized, it can be used via MUS Read or MUS Write. The boundaries and the size of an object are set at allocation, then they can be changed by any MAL or MDL operation.\nIf an object is owned by more than one pointer, Reallocate (in MAL or MDL) should be followed by Reposition over all these owners. A Deallocate an object operation should properly be followed by Reassign of all its pointers to either NULL or another object.\nFig 1. The BF Memory Bugs Model. Comprises four phases, corresponding to the BF classes MAD, MAL, MUS, and MDL. Shows the memory operations flow: blue arrows – the main flow; green arrows – flow for allocation at a specific address; red – extra flow in case of reallocation. - click on image for detailed view.\n"},{"id":24,"href":"/BF/BF-Classes/_RND/Model/","title":"Model","section":"Random Number Generation Bugs","content":"\rBF Randomness Model\r#\rRandomness\r#\rRandomness has application in many fields, including cryptography, simulation, statistics, politics, science, and gaming. Any specific use has its own requirements for randomness – e.g., random bit generation for cryptography or security purposes has stronger requirements than generation for other purposes. For cryptography or security purposes, the National Institute of Standards and Technology (NIST) recommends use of cryptographically secure Pseudo-Random Bit Generators (PRBGs). They are subject to the requirements in NIST SP 800-90A, NIST SP 800-90B and NIST SP 800-90C. Satisfying the requirements for a particular use can be surprisingly difficult.\nWeaknesses (bugs) in random number generators (RNGs) may lead to wrong results from the algorithms that use the generated numbers or allow attackers to recover secret values, such as passwords and cryptographic keys. Formalization of randomness bugs would help researchers and practitioners identify them and avoid security failures.\nRandomness Generation\r#\rWe separate randomness generation in two distinct processes: true-random number generation and pseudo-random number generation. The former is nondeterministic true-randomness generation (full entropy), while the latter is deterministic pseudo-randomness generation.\nTrue-random number generation uses entropy sources, while pseudo-random number generation uses true-random numbers as seeds. It is possible for a PRBG to use non-random seeds (e.g., for generating random numbers for simulation or game algorithms). PRBGs are used to extend the true-random seeds, produced from a True-Random Bit Generator (TRBG) output – if the seed has length n, the output of the PRBG can have length m, where m\u0026gt;n. However, a PRBG cannot increase the entropy of its seed.\nExamples of randomness related attacks are direct RSA common factor attack cryptanalytic attack, input based attack, state compromise attack. For that we have developed a general descriptive model of randomness and two randomness classes as part of the Bugs Framework (BF).\nThe BF Randomness Model\r#\rThe following figure presents our BF randomness bugs model, showing in which software components of TRNG and Pseudo-Random Number Generator (PRNG) bugs can occur. It is a descriptive and not as a prescriptive model. It should not be used as a model for construction of Random Bit Generators (RBGs). (\rNIST SP 800-90C specifies construction of RBGs using the mechanisms and entropy sources described in SP 800-90A and SP 800-90B, respectively.) TRN is the name of our BF class of True-Random Number Bugs. PRN is the name of our BF class of Pseudo-Random Number Bugs. The BF randomness model helps identify where in the corresponding bugs could occur. TRN covers bugs related to entropy sources, TRBG, and TRNG. PRN covers bugs related to entropy pools, PRBG, and PRNG. Although, output from the former process may be used as input to the latter (see the red arrow in Fig. 1), they are distinct from the point of view that bugs related to each have different causes, attributes, and consequences. The random bits are optionally converted in a pseudo-random number based on the range that applications provide as an argument.\nNIST SP 800-90A/B/C give specific requirements and architectures for approved RBGs.\n(TRN – True-Random Number Bugs\nPRN – Pseudo-Random Number Bugs TRBG: True-Random Bit Generator\nTRNG: – True-Random Number Generator PRBG – Pseudo-Random Bit Generator PRNG – Pseudo-Random Number Generator\nBC – Block Cipher) The BF Model of Randomness Bugs. It is a descriptive and not as a prescriptive model. It should not be used as a model for construction of RBGs.\nIf live entropy source is used, the PRBG is said to support prediction resistance. A PRBG without prediction resistance can still be used where an on-demand entropy source and immediate resetting are not required.\nPRNGs are algorithmic and can have bugs. Most PRNGs are not cryptographically secure.\n"},{"id":25,"href":"/BF/Home/Overview/","title":"Overview","section":"BF Home","content":"\rWelcome to the NIST Bugs Framework (BF) Project!\r#\rWe are classifying software bugs and weaknesses to allow precise descriptions of vulnerabilities that exploit them.\nThe Bugs Framework (BF) is a …\n➢ Structured\n➢ Complete\n➢ Orthogonal\n… classification system of software bugs and weaknesses, which is also independent from technology and programming languages specifics.\nStructured means a weakness is described via one cause, one operation, one consequence, and one value per attribute from the lists defining a BF class. This assures precise causal descriptions. Complete means BF has the expressiveness power to describe any software bug or weakness. This assures there are no gaps in coverage. Orthogonal means the sets of operations of any two BF classes do not overlap. This assures there are no overlaps in coverage. Classification system means bugs and weaknesses chain via cause–consequence–cause transitions. This assures back-tracking from the failure through errors to the bug. All these together resolve the imprecise descriptions problem. BF is also applicable for source code in any programming language and is technology independent.\nEach BF class is a taxonomic category of a weakness type. It relates to a distinct phase of software execution, the operations specific for that phase and the operands required as input to those operations. Operations or operands improperness define the causes. A consequence is the result of the operation over the operands. It becomes the cause for a next weakness or is a final error, leading to a failure. The attributes describe the operations and the operands. They help us understand the severity of the bug or the weakness.\nEach BF class has a strict definition and a taxonomy. The taxonomy of a class comprises:\nA set of operations – where such bugs could happen A set of causes – the possible improper operations and operands A set of consequences – improper operands for next weakness and the possible final errors A set of attributes with values – for the operations and the operands. Please watch our short intro presentation:\n"},{"id":26,"href":"/BF/Old/Classes/CIF/","title":"CIF","section":"Classes","content":"\rControl of Interaction Frequency Bugs (CIF) Class\r#\rDefinition\r#\rWe define Control of Interaction Frequency Bugs (CIF) as:\nThe software does not properly limit the number of repeating interactions per specified unit. In physics, frequency is the number of occurrences of a repeating event per unit time. Interactions in software could be also per event or per user.\nType\r#\rHigh (semantic).\nTaxonomy\r#\rFig. 1 depicts CIF causes, attributes and consequences.\nFig 1. Control of Interaction Frequency Bugs (CIF) Class - click on image for detailed view.\nAttributes\r#\rInteraction -- Authentication Attempt, Book, Checkout, Register, Initiate.\nThis indicates the type of interactions to be controlled. Voting could be related to election, census, survey, referendum and ballot. Booking could be of tickets, hotel rooms or rental cars. Checkout could be of library books, hotel rooms or rental cars. Register could be for computer games. Initiate could be for message exchange.\nAuthentication Event is the sequence of Authentication Attempts arriving at a particular server, possibly with the same partial credential, from any source, that terminates by successful authentication or by blocking.\nNumber – Single, Unique; Specified Number (\u0026gt; 1).\nThis indicates the maximum number of occurrences allowed.\nUnit – Time Interval, Event, User.\nThis indicates the specific unit per which the number of occurrences is controlled. Time Interval could be in seconds, in days, etc. Event could be election, authentication, on-line transaction to move funds, etc.\nActor – User, Part of Program Logic, Automated Process.\nThis indicates who/what is performing the repeating interactions. User could be authenticated user, attacker. Part of program logic could be message exchange. Automated process could be virus, bot.\nOur taxonomy makes it abundantly clear that CIF is a \u0026ldquo;metaclass\u0026rdquo; in some senses. External policies must define for each system or application what constitutes an interaction, how many interactions should be allowed, and the unit. Each policy, then, defines a different class of CIF concerns.\nCauses\r#\rThe graph of causes shows that there are two main causes: Number of Interactions not Checked Properly or Frequency of Interactions not Checked Properly.\nConsequences\r#\rThe graph of consequences shows what could happen due to the fault. Note that in the graph of consequences, Credentials concerns username or password, smart card and personal identification number (PIN), retina, iris, fingerprint, etc. Resource Exhaustion concerns memory, CPU or granted licenses.\nSites\r#\rSince the concept of interaction is so broad and high level, compared to most programming languages, no general description of what is a site is feasible. Each system or application must define its own concept of interaction. An interaction must then be mapped to some code that controls or authorizes said interactions. More importantly, since a failure may be the total lack of code to recognize and control frequency of interaction, there is often no particular line or even block of code that can be pointed out as missing the control code. An entire path may be indicated from the beginning of an interaction event, that is, an outside agent indicates desire to start an interaction, to the final chance in execution flow that code may refuse to authorize the event.\nRelated BF Classes\r#\rBF classes related to CIF are: IEX, ATN.\nRelated CWEs and SFP\r#\rCWEs related to CIF are CWE-307, CWE-799, CWE-837.\nThe only related SFP cluster is SFP34 Unrestricted Authentication under the Primary Cluster: Authentication.\nBF Descriptions of CIF Related CWEs are provided here.\nApplication\r#\rApplication examples are provided here.\nReferences\r#\r[1] I. Bojanova, P. E. Black, Y. Yesha, and Y. Wu, “The Bugs Framework (BF): A Structured approach to express bugs”, Proceedings of IEEE International Conference on Software Quality, Reliability and Security (QRS), 2016, , pp. 175-182.\n"},{"id":27,"href":"/BF/Old/Examples/CIF/","title":"CIF","section":"Examples","content":"\rControl of Interaction Frequency Bugs (CIF) Examples\r#\rCVE-2002-0628 BF Taxonomy Cause: Failure to Limit Attributes: Interaction: Authentication Attempt Number: Specificed Number Unit: Authentication Event Actor: User(s) Consequence: Credentials compromise (username or password) BF Description: \"Failure to limit to a specified number the authentication attempts per authentication event by same or different user(s) may be exploited for credentials compromise (username or password) via brute force.\" [2] CVE Description \"The Telnet service for Polycom ViewStation before 7.2.4 does not restrict the number of failed login attempts, which makes it easier for remote attackers to guess usernames and passwords via a brute force attack.\" [1] Analysis [1,3] include sufficient information for describing this CVE using BF. Source Code Code With Bug Code With Fix Source Code Not Available Source Code Not Available CVE-2002-1876 BF Taxonomy Cause: Failure to recognize repeated interactions leads to failure to properly limit Attributes: Interaction: Authentication Attempt Number: Specificed Number Unit: Specfied Time interval Actor: Authenticated Users Consequence: Resource exhaustion (consumption of all granted licenses) leading to DoS BF Description: \"Failure to recognize repeated interactions that are rapid initiations of message exchange requests from authenticated users, leads to failure to properly limit them to a specified number per specified time interval, which may be exploited for resource exhaustion (consumption of all granted licenses) leading to DoS.\" [2] CVE Description \"Microsoft Exchange 2000 allows remote authenticated attackers to cause a denial of service via a large number of rapid requests, which consumes all of the licenses that are granted to Exchange by IIS.\" [4] Analysis [4] includes sufficient information for describing this CVE using BF. Source Code Code With Bug Code With Fix Source Code Not Available Source Code Not Available CVE-2002-1018 BF Taxonomy Cause: Failure to limit Attributes: Interaction: Checkout Number: Single Unit: User Actor: User Consequence: Resource exhaustion (consumption of all granted licenses) leading to DoS BF Description \"Failure to limit the checkouts of a book to a single one per user may be exploited for resource exhaustion leading to DoS.\" [2] CVE Description \"The library feature for Adobe Content Server 3.0 does not verify if a customer has already checked out an eBook, which allows remote attackers to cause a denial of service (resource exhaustion) by checking out the same book multiple times.\" [5] Analysis [5] includes sufficient information for describing this CVE using BF. Source Code Code With Bug Code With Fix Source Code Not Available Source Code Not Available References [1] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2002-0628. [2] Irena Bojanova, Paul E. Black, Yaacov Yesha, and Yan Wu, The Bugs Framework (BF): A Structured Approach to Express Bugs, QRS 2016, Vienna, Austria. [3] The MITRE Corporation, CWE Common Weakness Enumeration, CWE-307: Improper Restriction of Excessive Authentication Attempts. [4] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2002-1876. [5] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2002-1018. "},{"id":28,"href":"/BF/Home/Concepts/","title":"Concepts","section":"BF Home","content":"#Software Security Concepts\nWe can observe that a security vulnerability leads to a security failure. However, what are the building blocks of a vulnerability? What is the defect in software that triggers a vulnerability? How does it propagate through errors until a final, exploitable error is reached? How do the underlying weaknesses of a vulnerability relate to these propagating errors?\nWe have developed the following definitions iteratively, while creating the BF software security vulnerability model. They help us reason about and create weakness taxonomies, allowing precise descriptions of existing vulnerabilities. We model a software security vulnerability as a chain of weaknesses that leads to a security failure. A security bug causes the first weakness, leading to an error. This error becomes the cause (i.e., the fault) for a next weakness and propagates through subsequent weaknesses until a final error is reached, causing the security failure.\nA software security vulnerability is a chain of weaknesses linked by causality. It starts with a bug and ends with a final error, which if exploited leads to a security failure.\nA software security weakness is a \\code{(bug, operation, error)} or \\code{(fault, operation, error)} triple. It is an instance of a weakness type that relates to a distinct phase of software execution, the operations specific for that phase and the operands required as input to those operations.\nA software security bug is a code or specification defect \u0026ndash; an operation defect.\nA software fault is a name, data, type, address, or size error \u0026ndash; an operand error. Name is in reference to a resolved or bound object, function, data type, or namespace. The others are in reference to an object.\nA software error is the result from an operation with a bug or a faulty operand. It becomes a next fault or is a final error.\nA software security final error is an exploitable or undefined system behavior that leads to a security failure.\nA security failure is a violation of a system security requirement.\nA chain of weaknesses starts with a bug, propagates through errors that become faults, and ends with a final error. The final error is the one exploited by attackers towards a security failure. For example, missing input validation may propagate to integer overflow, followed by buffer overflow, which if exploited may lead to a remote code execution failure.\nThe bug must be fixed to resolve the vulnerability; while, in most cases, fixing a fault would only mitigate the vulnerability. To fix a bug (code or specification defect), lines of code or configuration files, etc., must be changed. The bug is a concrete error; it is a wrong sequence of bits that must be changed. Fixing a specification is also code related, as it requires fixing its implementation.\nA security failure may be caused by the converging final errors of several vulnerabilities. The bug in at least one of the chains must be fixed to avoid the failure.\nUsing our definitions, we formalize at a high-level a vulnerability description with the following rules (the complete current BF LL1 grammar is available xxxhere).\nSTART := Vulnerability Converge\nVulnerability := Bug Operation Error\nError := Fault Operation Error | FinalError Converge := Vulnerability Converge | Failure END\n"},{"id":29,"href":"/BF/BF-Classes/_CRY/ENC/","title":"ENC","section":"Cryptographic Store and Transfer Bugs","content":"\rEncryption/Decryption Bugs (ENC) Class\r#\rNote\nThis class is still under development. The information will be updated soon.\nDefinition\r#\rWe define Encryption/Decryption Bugs (ENC) as follows:\nEncryption Bugs: The software does not properly transform sensitive data (plaintext) into unintelligible form (ciphertext) using a cryptographic algorithm and key(s).\nDecryption Bugs: The software does not properly transform ciphertext into plaintext using a cryptographic algorithm and key(s).\nNote that \u0026ldquo;transform\u0026rdquo; is for confidentiality.\nSee also the Model of Cryptographic Store or Transfer.\nType\r#\rHigh (semantic).\nTaxonomy\r#\rFig. 1 depicts ENC causes, attributes and consequences.\nFig 1. Encryption/Decryption Bugs (ENC) Class - click on image for detailed view.\nAttributes\r#\rSensitive Data – Credentials, System Data, State Data, Cryptographic Data, Digital Documents.\nThis is secret (confidential) data. Credentials include Password, Token, Smart Card, Digital Certificate, Biometrics (fingerprint, hand configuration, retina, iris, voice.) System Data could be configurations, logs, Web usage. Cryptographic Data is hashes, keys, keying material. Keying material is cryptographic keys, initialization vectors, shared secrets, domain parameters, random bits (seeds, salts, nonces).\nData State – Stored, Transferred.\nThis reflects if data is in rest or use, or if data is in transit. Secure store is needed for data that is in rest or use from files (e.g. ini, temp, configuration, log server, debug, cleanup, email attachment, login buffer, executable, backup, core dump, access control list, private data index), directories (Web root, FTP root, CVS repository), registry, cookies, source code \u0026amp; comments, GUI, environmental variables. Secure transfer is needed also for data in transit between processes or over a network.\nAlgorithm – Symmetric, Asymmetric.\nThis is the key encryption scheme used to securely store/transfer sensitive data. Symmetric (secret) key algorithms (e.g. Serpent, Blowfish) use one shared key. Asymmetric (public) key algorithms (e.g. Diffie-Hellman, RSA) use two keys (public, private).\nSecurity Service(s) – Confidentiality (and in some modes of encryption Integrity and Identity Authentication).\nThis is the security service that was failed by the encryption process. Confidentiality is the main security service provided by encryption. Those marked with ‘~’ are only for some specific modes of encryption.\nCauses\r#\rIn the graph of causes, modification of algorithm is remove/change or add a cryptographic step. Improper algorithm or step could be missing, inadequate, weak, risky/broken. Insecure mode of operation leads to weak encryption algorithm. Consequences\nSites\r#\rENC is a high level class, so sites do not apply.\nRelated BF Classes\r#\rBF classes related to ENC are: KMN, RND, and IEX.\nRelated CWEs and SFP\r#\rCWEs related to Encryption (although some are not ENC) are: CWE-256, CWE-257, CWE-261, CWE-311, CWE-312, CWE-313, CWE-314, CWE-315, CWE-316, CWE-317, CWE-318, CWE-325, CWE-326, CWE-327, CWE-329, CWE-780.\nRelated SFP clusters are SFP 17.1 Broken Cryptography and SFP 17.2 Weak Cryptography under Primary Cluster: Cryptography.\nBF Descriptions of ENC Related CWEs are provided here.\nApplication\r#\rApplication examples can be found here: CVE-2007-5460, CVE-2002-1697.\nReferences\r#\r[1] Bojanova, I., Black, P. E., Yesha, Y.,\rCryptography Classes in Bugs Framework (BF): Encryption Bugs (ENC), Verification Bugs (VRF), and Key Management Bugs (KMN). IEEE Software Technology Conference (STC 2017), NIST, Gaithersburg, USA. September 25-28, 2017.\n"},{"id":30,"href":"/BF/Background/Other-Classifications/","title":"Other Classifications","section":"Background","content":"\rOther Classifications\r#\rCommon Weakness Enumeration (CWE)\r#\rCommon Weakness Enumeration (CWE) is an encyclopedia of over 600 types of software weaknesses . Some of the classes are buffer overflow, directory traversal, OS injection, race condition, cross-site scripting, hard-coded password and insecure random numbers. CWE is a widely-used compilation, which has gone through many iterations. Many tools and projects are based on it. Each CWE has a variety of information, such as description summary, extended description, white box definition, consequences, examples, background details and other notes, recorded occurrences (Common Vulnerabilities and Exposures or CVE), mitigations, relations to other CWEs, and references.\nSoftware Fault Patterns (SFP)\r#\rSoftware Fault Patterns (SFP) are a clustering of CWEs into related weakness categories. Each cluster is factored into formally defined attributes, with sites footholds, conditions, properties, sources, sinks, etc. This work overcomes the problem of combinations of attributes in CWE. For instance, the SFP factored attributes are more clear than the irregular coverage of CWEs.\nThe NSA Center for Assured Software (CAS)\r#\rThe NSA Center for Assured Software (CAS) defines the following Weakness Classes in its \u0026ldquo;Static Analysis Tool Study - Methodology\u0026rdquo;\nSoftware State-of-the-Art Resources (SOAR)\r#\rThe Software State-of-the-Art Resources (SOAR) Matrix defines and describes a process for selecting and using appropriate analysis tools and techniques for evaluating software for software (security) assurance. In particular, it identifies types of tools and techniques available for evaluating software, as well as the following technical objectives those tools and techniques can meet :\nSEI CERT C Coding Standard\r#\rThe SEI CERT C Coding Standard defines the following \u0026ldquo;rules for secure coding in the C programming language\u0026rdquo; with the goal to \u0026ldquo;to develop safe, reliable, and secure systems, for example by eliminating undefined behaviors that can lead to undefined program behaviors and exploitable vulnerabilities\u0026rdquo;\nCommon Vulnerabilities and Exposures (CVE)\r#\rThe Common Vulnerabilities and Exposures (CVE) is \u0026ldquo;a dictionary of publicly known information security vulnerabilities and exposures\u0026rdquo; . \u0026ldquo;CVE’s common identifiers enable data exchange between security products and provide a baseline index point for evaluating coverage of tools and services.\u0026rdquo;.\nOpen Web Application Security Project (OWASP)\r#\rThe Open Web Application Security Project (OWASP) defines 20 categories of vulnerabilities.\nCommon Attack Pattern Enumeration and Classification (CAPEC)\r#\rThe Common Attack Pattern Enumeration and Classification (CAPEC) \u0026ldquo;is a comprehensive dictionary and classification taxonomy of known attacks that can be used by analysts, developers, testers, and educators to advance community understanding and enhance defenses\u0026rdquo;\nISO/IEC JTC1/SC22/WG23 Technical Report\r#\rISO/IEC/JTC 1/SC 22/WG 23 is working on a Technical Report (RT), which includes a \u0026ldquo;taxonomic hierarchy of vulnerabilities\u0026rdquo;, giving each vulnerability an arbitrary three-letter code . The general part, TR 24772-1, is an and applies to all languages. There are many supplements, one for each language \u0026ndash; for example, TR24772-2 Ada, TR24772-3 C, and TR24772-9 C++.\n"},{"id":31,"href":"/BF/BF-Classes/_DAT/Validation/","title":"Validation","section":"Data Type Bugs","content":"\rValidation\r#\rIn this section, we analyze the correspondence of the data type related CWEs, such as Numeric Errors , Type Errors, and String Errors, to the four newly developed BF Data Type Bugs classes. We show that DCL, NRS, TCV, and TCM cover all data type related CWEs, and potentially beyond, while providing a better structured way for describing these kinds of bugs/weaknesses.\nWe identified data type related CWEs in three steps: 1) CWE Filtering: Since different types of bugs/weaknesses are described in CWE, we filtered a set of CWEs which de- scriptions contain keywords such as ”type”, ”string”, ”class”, ”cast”, and ”compare”. 2) Automated Extraction: Starting from the filtered CWEs and following their parent-child relationships, we extracted all the clusters of potentially data type related CWEs. 3) Manual Review: All the authors, who are a team of professional security researchers, performed iterative rounds of manual CWE reviews, identifying the type related CWEs among the extracted CWE clusters. Finally, we could collect 84 CWEs, 78 of which are data type related. The additional six CWEs: 573, 664, 668, 710, 758, and 1076 (shown with gray outline) were included only for parent-child completeness. We peer-reviewed their detailed descriptions, examples, and listed CVEs, as well as the corresponding literature; and performed weekly discussions brainstorming to confirm each of these CWEs is covered by the operations, causes, and/or consequences defining the BF Data Type Bugs classes.\nWe mapped each of the identified CWEs to a BF Data Type Bugs class based on the operations that are defined in DCL, NRS, TCV, and TCM and identified an operation for the CWE. Then, we generated digraphs of all data type related CWEs to show their correspondence to the BF Data Type Bugs classes by operation (Fig. 1) and by consequence (Fig. 8). In the digraphs, each node is a CWE weakness, shown by its CWE ID, and the edges show the parent/child relationship. The outline style of a CWE node indicates the abstraction level: pillar, class, base, or variant.\nIn Fig. 1, the outline color of a CWE node indicates the BF class(es) and operation(s) associated with that CWE: DCL Declare, DCL Define, NRS Refer, NRS Call, TCV Cast, TCV Coerce, TCM Calculate, and TCM Evaluate.\nMost of the CWEs, visualized on the digraphs, are covered by the DCL class. They relate to improper declaration and definition of structured data and are under the pillars CWE-664 (Improper Control of a Resource Through its Life-time) and CWE-668 (Exposure of Resource), and CWE-710 (Improper Adherence to Coding Standards), correspondingly.\nTwo other large clusters of data type related CWEs are covered by TCM. They relate to improper calculation and evaluation and are descendants of the pillars CWE-682 (Incorrect Calculation) and CWE-697 (Incorrect Comparison), correspondingly. Two of the CWE-628 (Function Call with Incorrectly Specified Arguments) descendants are also covered by TCM Calculate and Evaluate. In addition, CWE-351 (Insufficient Type Distinction) is covered by TCM Evaluate.\nThe CWEs covered by TCV are under CWE-704 (Incorrect Type Conversion or Cast). They mostly relate to improper coercion – CWE-843 (Access of Resource Using Incompatible Type (’Type Confusion’)) and the children of CWE-681 (Incorrect Conversion between Numeric Types). Only one CWE was identified as improper casting – CWE- 588 (Attempt to Access Child of a Non-structure Pointer).\nOnly a few CWEs are partly related to the NRS class, which is surprising as bugs related to polymorphic calls are not rare. Our explanation is that CWE considers improper name referring/resolving and improper function calling/binding to be part of a computation weakness. For in- stance, CWE-468 is under CWE-682 (Incorrect Calculation), but it lists an example that starts with a TCV bug leading to an NRS weakness, and is actually a five weaknesses chain.\nFig. 3 shows the percentages of data type related CWEs by BF class operation. It shows that most of these CWEs are about weaknesses that occur at declara- tion and definition (47.8% combined) of objects, types, and functions. Next are weaknesses related to performing data type related calculations or evaluations (28.9% combined). The least represented are the name resolution (at refer and call) and type conversion (at cast and coerce) weaknesses.\nWhile the CWEs only enumerate weaknesses, the Data Type Bugs classes ensure precise descriptions, as a weak- ness is described via one cause, one operation, and one consequence. The CWEs exhaustive list is prone to gaps in coverage and some weakness types may be missing. For example, in the type related categorization the CWEs are mainly focused on primitive data type errors, such as Numeric Errors and String Errors, while our developed BF classes consider both primitive and structured data types. Besides that, the data type related CWEs focus mostly on types of errors that happen during arithmetic calculations and comparison evaluations, while the BF Data Type Bugs classes define type related bugs based on different stages of the data types development: from declaration and definition to resolution and usage.\nThe BF Data Type Bugs classes present a taxonomy with structured cause→consequence relations that is complete and orthogonal. It could be viewed as a structured extension over the CWEs related to Wrong Result, Rounded Value, Truncated Value, Wrap Around (incl. Integer Overflow), Under Range, Over Range Flipped Sign, Wrong Access, and Undefined Behaviour (see Fig. 2). It is a taxonomy that explains the causal relationships between weaknesses and would be easier to use than the nested hierarchical CWEs.\nMany bug reporting tools use the CWE to describe detected bugs/weaknesses. As a structured extension over the data type related CWEs, the BF Data Type taxonomy can be used to report identified data type related bugs/weaknesses (including those leading to integers overflow, juggling, and pointer arithmetic errors). Fig. 1 shows how data type related CWEs translate to BF DCL, NRS, TCV, TCM by operation; Fig. 2 shows how they translate by consequences.\nFig. 1: A digraph of the data type related CWEs, mapped by DCL, NRS, TCV, and TCM operations. Each node represents a CWE ID. Each arrow represents a parent-child relationship.\nFig. 2: A digraph of the data type related CWEs, mapped by BF DCL, NRS, TCV, and TCM consequences. Each node represents a CWE ID. Each arrow represents a parent-child relationship.\nFig 3. A diagram of the percentages of data type related CWEs by the operations of the BF Data Type Bugs classes. - click on image for detailed view.\n"},{"id":32,"href":"/BF/BF-Classes/_INP/Validation/","title":"Validation","section":"Input/Output Check Bugs","content":"\rValidation\r#\rIn this section, we analyze the correspondence of the input, output, and injection-related CWEs to the two new BF DVL and DVR classes. We show that the BF classes cover all related CWEs, and potentially beyond, while providing a better structured way for describing these kinds of bugs/weaknesses.\nThe BF classes ensure precise causal descriptions, as a weakness is described via one cause, one operation, and one consequence, while the CWEs only enumerate weaknesses. The CWEs exhaustive list approach is prone to gaps in coverage: some weakness types may be missing. The CWEs also have overlaps in coverage, including via over detailing (e.g., CWE-23 children’s path traversal variations). While by their nature, the BF classes are complete and orthogonal, assuring no gaps and no overlaps in coverage. We map a CWE to a BF class by an operation and/or a consequence from the lists defining the BF class. Through these relationships, the BF classes can be viewed as structured extensions to the input, output, and injection-related CWEs.\nThe BF Data Check Bugs classes relate to particular CWEs by BF DVL and DVR operations and/or consequences. We generated a digraph of all input- and output-check-related CWEs, including the injection-related CWEs, to show this correspondence both by operation (Fig. 1) and by conse- quence (Fig. 2). In the digraph, an edge starts at a parent CWE and ends at a child CWE. The outline style of a CWE node indicates the CWE level of abstraction: pillar, class, base, or variant.\nAlmost all of the 162 CWEs, visualized on the digraph, can be tracked as descendants of the pillar CWE-707; exceptions are CWEs 15, 73 (its child 114), 98, 134, 183, 184, 185 (and its children 186 and 625), 428, 472, 565, and 913.\nAnalyzing the digraph, we see that the pillar CWE- 707 reflects neutralization of malformed messages; it is quite broad. It is the parent of several CWEs that are not strictly input/output check related.\nThe digraph helped us identify seven distinct clusters of CWEs with parent CWEs 20, 22, 41, 74, 116, 138, and 228.\nMost CWEs are about input check. CWEs-116 and its children, CWEs 117 and 644, are about output check. CWEs 80, 81, 82, 83, 84, 85, 86, and 87 are about both input check and output check.\nIn Fig. 1, the outline color of a CWE node indicates the BF class(es) and operation(s) associated with that CWE: DVL Validate, DVL Sanitize, DVR Verify, and DVL Validate and DVR Verify. There are no CWEs that relate to DVR Correct. The CWE-20 cluster is the only one that corresponds to DVR Verify. However, some of its descendants correspond also to DVL Validate. The CWE-41 and CWE-228 (except 3 nodes) clusters correspond to DVL Validate. The rest of the clusters, CWE-22, CWE-74, CWE-116, and CWE-138, correspond to DVL Sanitize.\nThe digraph on Fig. 2 illustrates how the CWEs map to BF DVL and DVR by consequence.\nIn Fig. 2, the outline color of a CWE node indicates the BF class consequence associated with that CWE: Query Injection, Command Injection, Source Code Injection, Pa- rameter Injection, File Injection, Invalid Data, Wrong Value, Inconsistent Value, or Wrong Type.\nThe CWE-74 cluster is all about injection; the largest group there is Source Code Injection, then are Query Injection and Command Injection, and a few nodes of File Injection and Parameter Injection. CWEs 74, 75, 76, 913, 914 are not colored, as they are about general injection errors. The CWE-22 and CWE-41 clusters are all about File Injection. The CWE-138 cluster is mostly about Parameter Injection and some Source Code Injection. Some of the CWE-138 nodes correspond to the DVL Invalid Data for Next Operation consequence. The CWE-20 cluster (which is DVR related) has nodes corresponding to the DVR Wrong Data for Next Operation consequences; however, some of these CWEs describe only causes and do not list consequences.\nAll relationships to input, output, and injection CWEs (Fig. 2) by BF DVL and BF DVR consequences are as follows:\nThe DVL class relates to CWEs through its Wrong Data for Next Operation consequence as follows: Invalid Data – CWEs: 138, 153, 155, 158, 159, 160, 162, and 164. The DVL class relates to CWEs also through its Injec- tion Error consequences as follows: Query Injection – CWEs: 89, 90, 91, 564, 643, 652, and 943; Command Injection – CWEs: 77, 78, and 624; Source Code Injection – CWEs: 79, 80, 81, 83, 82, 85, 86, 87, 94, 95, 96, 97, 98, 149, 692, 917, and 1336; Parameter Injection – CWEs: 88, 93, 113, 134, 140, 141, 142, 143, 144, 145, 146, 147, 148, 150, 151, 152, 154, and 157; File Injection – CWEs: 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 73, 99, 117, 641, and 1236. The DVR class relates to CWEs through its Wrong Data for Next Operation consequence as follows: Wrong Value – CWEs: 129, 170, 606, 781, 1285, and 1289; Inconsistent Value – CWEs: 130, 230, 232, and 1288; Wrong Type – CWEs: 1284, and 1287. The following CWEs reflect only DVL or DVR causes: 102, 105, 106, 108, 109, 183, 184, 185, 186, 228, 229, 231, 233, 234, 235, 236, 237, 238, 239, 240, 554, 625, 1173, and 1174. The BF Data Check Bugs classes present a taxonomy with structured cause/consequence relations that is complete and orthogonal. It could be viewed as a structured extension over the CWEs related to Injection Errors, Invalid Data, Wrong Value, Inconsistent Value, and Wrong Type (Fig. 2). It is a taxonomy that explains the causal relationships between weaknesses and would be easier to use than the nested hierarchical CWEs.\nMany bug reporting tools use the CWE to describe found bugs/weaknesses. As a structured extension over the input, output, and injection CWEs, the BF Data Check taxonomy can be used to report found data check bugs/weaknesses (including those leading to injection errors). Fig. 1 shows how input/output and injection CWEs translate to BF DVL and BF DVR by operation; Fig. 2 shows how they translate by consequences.\nFig. 1: A digraph of the input- and output-check-related CWEs (including injection-related CWEs), mapped by BF DVL and BF DVR operations. Each node represents a CWE by its identifier (ID). Each arrow represent a parent-child relationship\nFig. 2: A digraph of the input- and output-check-related CWEs (including the injection-related CWEs), mapped by BF DVL and BF DVR consequences. Each node represents a CWE by its identifier (ID). Each arrow represent a parent-child relationship\n"},{"id":33,"href":"/BF/BF-Classes/_MEM/Validation/","title":"Validation","section":"Memory Bugs","content":"\rValidation\r#\rBF Memory Bugs taxonomy can be used by bug reporting tools, as it is a structured extension over memory-related CWEs. All Memory Error consequences from the BF classes relate to one or more CWEs.\nWe have generated a digraph (Fig. 1) of all memory-related CWEs to show how they correspond to the possible BF Memory Error consequences. An edge starts at a child CWE and ends at a parent CWE. The outline of a CWE node indicates the CWE abstraction level: dashed triple line is for variant, double line is for base, single line is for class, and thick red line is for pillar. Bug reporting tools would use base or variant CWEs, but they may also use higher abstraction level CWEs if there is not enough specific information about the bug or if there is no related base CWE.\nThe digraph helped us identify four clusters of memory- related CWEs. All these CWEs can be tracked as children of the pillar CWE-664, with the only exception of CWE-476 (NULL Pointer Dereference). The largest cluster comprises the children of CWE-119, which are weaknesses associated with reading and writing outside the boundaries of an object. The second-largest cluster comprises the children of CWE- 400 and CWE-665, which are mainly weaknesses related to memory allocation and object initialization. The children of CWE-404, which are weaknesses associated with improper memory release, form the third cluster. The smallest cluster comprises CWE-704, CWE-588 and CWE-843, which are memory use or deallocation weaknesses due to the mismatch between pointer and object types.\nThe color of a CWE node (Fig. 1) indicates the BF memory class associated with that CWE. A BF class is associated with a CWE if the BF class has a Memory Error consequence covered by the CWE description. CWEs related to the BF MUS memory errors are presented in blue, CWEs related only to MAL are presented in pink, and CWEs related to both MAL and MDL are presented in green.\nMost of the BF MUS Memory Error consequences relate to CWEs from the first cluster. The Memory Error consequences from BF MAL and BF MDL relate to CWEs across clusters. Note that the BF MAD class has no Memory Error consequences, so it does not directly relate to any CWE.\nThe BF Memory Bugs model reflects the lifecycle of an object. The pillar CWE-664 also reflects the “lifetime of creation, use, and release” of a resource. However, it is quite broad; it is the parent of many CWEs that are not strictly memory-related. We use asterisks (*) to denote CWEs that are about any resource. CWE-704 is not a memory-related CWE, but is visualized on the digraph to show all the child-parent relationships.\nThe clusters of memory CWEs do not strictly correspond to the phases of address formation, allocation, use, and deallocation. CWEs related to a phase appear in more than one cluster. In addition, CWE-118 and CWE-119 are strictly about memory but cover more than one phase.\nViewed as a structured extension, the BF Memory Bugs classes relate to CWEs through particular Memory Error consequences. For BF MAL: Memory Overflow – relates to CWEs: 400*, 770*, and 789; Memory Leak – to CWEs: 401, 404*, and 771*; Double Free – to CWE-415; Object Corruption – to CWEs: 404*, 590, 761, 762, and 763.\nFor BF MUS: Uninitialized Object – relates to CWEs: 457, 456, CWE-665*, 908*, and 909*; Not Cleared Object – to CWEs: 226*, 244, and 459*; NULL Pointer Dereference – to CWE-476; Untrusted Pointer Dereference – to CWEs: 119 and 822; Type Confusion – to CWEs: 588 and 843*; Use After Free – to CWEs: 119,416, and 825; Buffer Overflow – to CWEs: 118, 119, 120, 121, 122, 123, 125, 126, 466, 805, 806, 787, and 788; Buffer Underflow – to CWEs: 118, 119, 122, 123, 124, 125, 127, 466, 786, 787, 805, and 806; Unitialized Pointer Dereference – to CWEs: 119 and 824. There are no related CWEs to BF MUS Object Corruption.\nFor BF MDL: Memory Leak – relates to CWEs: 401, 404*, and 771*; Double free – to CWE-415; Object Corruption – to CWEs: 404*, 761, 762, and 763.\nFig 1. A digraph of all memory related CWEs. Dashed triple line – variant, double line – base, single line – class, and thick red line – pillar. BF class correspondence: pink is only for MAL, green is for both MDL and MAL, and blue is for MUS.\n"},{"id":34,"href":"/BF/BF-Classes/_DAT/DCL/","title":"DCL","section":"Data Type Bugs","content":"\rDeclaration Bugs (DCL) Class\r#\rDefinition\r#\rWe define Declaration Bugs (DCL) as follows:\nAn object, a function, a data type, or a namespace is declared or defined improperly. Taxonomy\r#\rFig. 1 depicts DCL causes, attributes and consequences.\nFig 1. Declaration Bugs (DCL) Class - click on image for detailed view.\nOperations\r#\rThe DCL operations are: Declare and Define. They reflect the improper declaration or definition of an object, a function, a data type, or a namespace.\nOperation Value Definition Declare Specify name and data type of an object; name, return data type, and parameters of a function; or name and type parameters of a data type. Define Specify data of an object; implementation of a function; or member objects and functions of a data type. Causes\r#\rThe graph of causes shows that there are three main causes for declaration bugs: Improper Operation, Improper Modifier, Improper Scope and Improper DataType. Improper Operation Value Definition Examples Missing The operation is absent. Missing: constructor +(int,double) overload function override in subtype. Wrong An inappropriate data type is specified; or an inappropriate function/operator is used. An object is declared int, while it should be float. A class implements a cloneable or a serializable interface. Comparison via = vs. ==. Erroneous The Type System or a compute function implementation has a bug. Incorrect data type inference. Wrong order or number of arguments to a function call. Incorrect deep objects comparison implementation. Operands Concept Definition Data Value A numeric, text, pointer/address, or boolean value stored in an object’s memory. Data Type A set of allowed values and the operations allowed over them. Function An organized block of code that when called takes in data, processes it, and produces a result(s). Consequences\r#\rThe graph of consequences shows Improper Data Type, Improper Function, and Access Errors as consequences. Improper Data Type Concept Definition Wrong Type Data type range or structure is not correct. Wrong Type Resolved Data type is resolved from wrong scope. Wrong Object Resolved Type Object is resolved from wrong scope,so it’s data type might be wrong. Wrong Sign Type Unsigned instead of signed data type is specified or vise versa. Wrong Precision Type Higher precision data type is needed (e.g. double instead of float). Incomplete Type Specific constructor, method, or overloaded function is missing. Mismatched Argument Type Argument’s data type is different from function’s parameter data type. Wrong Generic Type Generic object instantiated via wrong type argument. Confused Subtype Object invoking an overriden function is of wrong subtype data type. Wrong Argument Type Argument to an overloaded function is of wrong data type. Improper Function Concept Definition Missing Overridden Function Function implementation in a particular subclass is absent. Missing Overloaded Function Implementation for particular function parameters’ data types is absent. Wrong Function Resolved Function is resolved from wrong scope. Wrong Generic Function Bound Implementation for a wrong data type is bound due to wrong generic type arguments. Wrong Overridden Function Bound Implementation from wrong subtype is bound due to a wrong invoking subtype object. Wrong Overloaded Function Bound Wrong overloaded implementation is bound due to wrong function arguments. Access Errors Value Definition Wrong Access Object Unauthorized access to an object exposes sensitive data or allows access to member functions. Wrong Access Type Unauthorized access to a data type allows access to member objects and functions. Wrong Access Function Unauthorized access to a function. Attributes\r#\rThe attributes of DCL are: Name Value Definition Source Code Codebase The operation is in programmer’s code – in the application itself. Third Party The operation is in a third party library. Standard Library The operation is in the standard library for a particular programming language. Compiler/Interpreter The operation is in the language processor that allows execution or creates executables (compiler, assembler, interpreter). Data Type Kind Primitive Mimics the hardware units and is not built from other data types – e.g. int (long, short, signed), float, double, string, boolean. Structured Builds of other data types; have members of primitive and/or structured data types – e.g. array, record, struct, union, class, interface. Mechanism Simple A non-polymorphic entity. Generics An entity parameterized by type. Overriding Functions with the same name as one in the base type, but implemented in different subtypes. Overloading Functions with the same name in the same declaration scope, but implemented with different signature. Entity Object A memory region used to store data. Function An organized block of code that when called takes in data, processes it, and returns a result. Data Type A set or a range of values and the operations allowed over them. Namespace An organization of entities’ names, utilized to avoid names collision. Sites\r#\rDCL sites are the entities declarations and definitions.\nApplication\r#\rApplication examples can be found here: CVE-2021-21834, CVE-2021-23440, CWE-468.\n"},{"id":35,"href":"/BF/BF-Classes/_INP/DVL/","title":"DVL","section":"Input/Output Check Bugs","content":"\rData Validation Bugs (DVL) Class\r#\rDefinition\r#\rWe define Data Validation Bugs (DVL) as follows:\nData are validated (syntax check) or sanitized (escape, filter, repair) improperly. Taxonomy\r#\rFig. 1 depicts DVL causes, attributes and consequences.\nFig 1. Data Validation Bugs (DVL) Class - click on image for detailed view.\nOperations\r#\rThe DVL operations are: Validate and Sanitize. They reflect the improper check and modification of data syntax.\nOperation Value Definition Validate Check data syntax (proper form/grammar) in order to accept (and possibly sanitize) or reject it. Includes checking for missing symbols/elements. Sanitize Modify data (neutralize/escape, filter/remove, repair/add symbols) in order to make it valid (well-formed). Causes\r#\rThe graph of causes shows that there are three main causes for data validation bugs: Improper Operation, Improper Data, and Improper Policy.\nImproper Operation Value Definition Example Missing The operation is absent. Missing data sanitization. Erroneous There is a bug in the implementation of the operation (incl. how it checks against a policy). Using not equal to (!=) when comparing to safelist values. Using greater than (\u003e) when checking for upper range. Under-Restrictive Policy Accepts bad data. Permissive safelist or regular expression. Incomplete denylist. Over-Restrictive Policy Rejects good data. Over-restrictive denylist or regular expression. Improper Data Value Definition Corrupted Data Unintentionally modified data due to a previous weakness (e.g., with a decompress or a decrypt operation) that if not sanitized would end-up as invalid data for next weakness. Tampered Data Maliciously modified data due to a previous weakness (e.g., with a deserialize, authorize, or crypto verify operation) that would lead to injection error. Improper Policy Value Definition Corrupted Policy Unintentionally modified policy due to a previous weakness (e.g., with a decompress operation). Tampered Policy Maliciously modified policy due to a previous weakness (e.g., with an authorize operation). Consequences\r#\rThe graph of consequences shows Improper Data for Next Operation and Injection Error as consequences.\nImproper Data for Next Operation Value Definition Invalid Data Data with harmed syntax due to sanitization errors. Injection Error Value Definition Example Query Injection Malicious insertion of condition parts (e.g., or 1==1) or entire commands (e.g., drop table) into an input used to construct a database query. SQL Injection No SQL Injection XPath Injection XQuery Injection LDAP Injection Command Injection Malicious insertion of new commands into the input to a command that is sent to an operating system (OS) or to a server. OS Command Injection Regular Expression Injection IMAP/SMTP Command Injection Object Injection (JSON server side) Source Code Injection Malicious insertion of new code (incl. with \u003c\u003e elements) into input used as part of an executing application code. Cross Site Scripting (XSS) CSS Injection Eval Injection EL Injection JSON Injection (Client or Server Side) Parameter Injection Malicious insertion of data (e.g., with \u0026 parameter separator) into input used as parameter/argument in other parts of code. Argument Injection Format String Injection Email Injection HTTP Header Injection (incl. Server Header Injection) Reflection Injection Flash Injection CRLF Injection (incl. HTTP Header Splitting) File Injection Malicious insertion of data (e.g., with .. and / or with file entries) into input used to access/modify files or as file content. CSV, Temp, etc. File Injection Log Entry Injection XML Injection CRLF Injection (incl. in as in log entry files) Relative Path Traversal Absolute Path Traversal Attributes\r#\rThe attributes of DVL are:\nName Value Definition Mechanism Safelist Policy based on a set of known good content. Denylist Policy based on a set of known bad content; helps reject outright maliciously malformed data. Format Policy based on syntax format (e.g., defined via regular expression). Length Policy based on allowed number of characters in data. Note that this is not about the data value as size of an object. Source Code Codebase The operation is in programmer’s code – in the application itself. Third Party The operation is in a third party library. Standard Library The operation is in the standard library for a particular programming language. Language Processor The operation is in the tool that allows execution or creates executable (compiler, assembler, interpreter). Execution Space Local The bugged code runs in an environment with access control policy with limited (local user) permission. Admin The bugged code runs in an environment with access control policy with unlimited (admin user) permission. Bare-Metal The bugged code runs in an environment with-out privilege control. Usually, the program is the only software running and has total access to the hardware. State Entered Data comes from user interface (e.g., text field). Stored Data comes from permanent storage (e.g., file, database on a storage device). In Use Data comes from volatile storage (e.g., RAM, cache memory). Transferred Data comes via network (e.g., connecting analog device or another computer). Sites\r#\rA site for input/output check bugs is any part of the code that should check and sanitize data syntax or check and correct data semantics.\nApplication\r#\rApplication examples can be found here: CVE-2020-5902, CVE-2019-10748.\n"},{"id":36,"href":"/BF/Old/Examples/IEX/","title":"IEX","section":"Examples","content":"\rInformation Exposure (IEX) Examples\r#\rCVE-2007-5172 This vulnerability is listed in [1] and discussed in [2, 3]. BF Taxonomy IEX 1 of password leads to ATN leads to IEX 2. IEX 1 Cause: Improper Details (error message displays password) Attributes: Information: Credentials (password) Sensitivity: High Information State: Stored Information Size: Little Exposure: Selective Frequency: On-Demand Channel: Legitimate (connection error message) Use: Indirect Consequences: ATN. ATN (to be described in a subsequent publication) IEX 2 Cause: Failure to Properly Protect Sensitive Data (password) Attributes: Information: Any (user data) Sensitivity: Low/High Information State: Stored Information Size: Huge Exposure: Selective Frequency: On-Demand Channel: Legitimate Use: Direct (valuable on its own) Consequences: Any IEX consequence. Analysis (based on [1–3): CVE-2007-5172 Description: “Quicksilver Forums before 1.4.1 allows remote attackers to obtain sensitive information by causing unspecified connection errors, which reveals the database password in the resulting error message.\" [1]. CVE-2003-0243 This vulnerability is listed in [30] and discussed in [5, 6]. BF Taxonomy IEX 1 of password leads to ATN leads to IEX 2. IEX 1 Cause: Program Behavior (different responces for correct vs incorrect password) Attributes: Information: Credentials (password) Sensitivity: High Information State: Used Information Size: Little Exposure: Selective Frequency: On-Demand Channel: Side (response inconsistency -- message replies allow brute force password guessing) Use: Indirect Consequences: ATN. ATN (to be described in a subsequent publication) IEX 2 Cause: Failure to Properly Protect Sensitive Data (password) Attributes: Information: Any (user data) Sensitivity: Low/H igh Information State: Stored Information Size: Huge Exposure: Selective Frequency: On-Demand Channel: Legitimate Use: Direct (valuable on its own) Consequences: Any IEX consequence. Analysis (based on [4-6]): CVE-2004-0243 Description: “AIX 4.3.3 through AIX 5.1, when direct remote login is disabled, displays a different message if the password is correct, which allows remote attackers to guess the password via brute force methods.\" [4]. CWE-203 Description: “The product behaves differently or sends different responses in a way that exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.\" [5]. “For example, the message reply for an incorrectly guessed password might be \"Incorrect userid or password\" whereas a correct guess would yield a message such as \"Remote logins for this account are not allowed\".” [6] CVE-2004-1602 This vulnerability is listed in [7] and discussed in [8-10]. BF Taxonomy IEX 1 of username leads to IEX 2 of password leads to ATN leads to IEX 3 IEX 1 Cause: Program Behavior (different time for valid vs invalid username) Attributes: Information: Credentials (username) Sensitivity: High Information State: Stored Information Size: Little Exposure: Selective Frequency: Once Channel: Covert (timing inconsistency -- server response timing allows finding valid usernames) Use: Indirect Consequences: IEX 2 (of password) IEX 2 Cause: Failure to Properly Protect Sensitive Data (username). Attributes: Information: Credentials (passwords) Sensitivity: High Information State: Stored Information Size: Little Exposure: Selective Frequency: Once Channel: Legitimate Use: Indirect Consequences: ATN. ATN (to be described in a subsequent publication) IEX 3 Cause: Failure to Properly Protect Sensitive Data (password) Attributes: Information: Any (user data) Sensitivity: Low/H igh Information State: Stored Information Size: Huge Exposure: Selective Frequency: On-Demand Channel: Legitimate Use: Direct (valuable on its own) Consequences: Any IEX consequence. Consequences: Any IEX consequence. Analysis (based on [7-10]): Using execution path timing analysis attack at the ProFTPD login procedure, an attacker can determine “which user names are valid, which are special, and which ones do not exist on the remote system” [9]. The timing attack on the username is followed by a brute force attack on the password when the username is already known as a result of the timing attack CVE-2017-5753 and CVE-2017-5715 (Spectre) This vulnerability is listed in [11, 12] and discussed in [13-21]. BF Taxonomy Cause: Hardware Behavior (caching results in reduced access time, and this outcome of speculative execution based on the wrong branch is not undone.) Attributes: Information: Any (user’s data) Sensitivity: High Information State: Stored Information Size: Huge Exposure: Selective Frequency: On-Demand Channel: Side (cache based timing) Use: Any Consequences: Any IEX consequence. Analysis (based on [11-21]): The attacker uses a cache timing channel using Flush+Reload [16], [17] and Evict+Reload [17], [18]. This is based on the fact that access to cached data requires less time. Mis-training of the processor by the attacker results in the processor’s speculative execution based on a wrong branch. This execution affects the cache in a certain way, and timing can be used to recover information about the cache state, which exposes user’s data. CVE-2017-5754 (Metltdown) This vulnerability is listed in [22] and discussed in [20-24]. BF Taxonomy Cause: Hardware Behavior (CPU out of order execution and caching allows overcoming memory isolation – discrepancy detected is between access time to cache memory and access time to non-cache memory, and this outcome of out of order execution of forbidden access is not undone.) Attributes: Information: Any (e.g. passwords stored in password manager or browser, personal photos, emails, instant messages and even business-critical documents) Sensitivity: High Information State: Stored (in kernel-memory registries of other processes or virtual machines in the cloud) Information Size: Huge Exposure: Selective Frequency: On-Demand Channel: Covert (out of order execution and cache-based timing) Use: Any Consequences: Any IEX consequence. Analysis (based on information in [19-24]): Meltdown overcomes the OS memory isolation, which ensures user programs cannot access each other’s memory or kernel memory. “It breaks all security guarantees provided by address space isolation as well as para-virtualized environments and, thus, every security mechanism building upon this foundation.” [23] A crucial observation is that in this attack, speculative execution enables access by the processor to memory that the attacker is not allowed to access. This is done before that forbidden access is blocked. Later, because the forbidden access had to be blocked, its effects are undone, excluding caching. Because caching was not undone, the effect on cache state can be measured using access time measurement [4], [11], [12]. The attacker runs code that implements a covert timing channel. That code transmits values over that channel using indirect addressing and out of order execution, and also recovers the transmitted values using time measurements. The operation of the timing covert channel can be explained using the toy example in [4], which includes the following line that will never be reached: “access(probe_array[data * 4096]);” Here data is secret information that is not accessible to the attacker. However, the hardware, not knowing whether the above instruction will be executed, executes it out of order so that the outcome to be available in case its execution will be needed. In the Meltdown attack, as in the toy example, out of order execution of an instruction results in data being accessed, in anticipation of the possibility that its execution will be needed. This can happen even when access by the attacker’s code will never be done. As in the toy example, the attacker uses instructions that are executed out of order by the processor, and this results in indirect access to cache lines with access addresses that depend on the secret value that is not accessible to the attacker. This includes the possibility of selecting access or no access depending on the secret value: for each bit of the secret value, access if the bit value is 0, and no access if the bit value is 1 [4]. At the other end of the covert channel, access time measurement can be used to determine whether a particular cache line was accessed, in order to find out whether the transmitted bit was a 0 or a 1. A timing covert channel is established using the Flush+Reload technique in [16]. It is based on the observation that access time depends on whether an address was cached. Therefore, access time measurements are used to determine which addresses were cached. Access time to the addresses that were cached is lower. The cached addresses are used to compute the secret value. For example, in the toy example the secret value is the cached address divided by 4096. In Meltdown, the attacker controls and has access to both the transmitting end and the receiving end of the covert timing channel. Access time measurements are done as follows: Let S be a set of addresses. All addresses in S are accessed, and access time is measured for each one of them. This enables finding all addresses in S that were cached, because the measured access time to each one of them is much lower than the measured access time to each address in S that was not cached. References [1] The MITRE Corporation. CVE-2007-5172. http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5172. [2] The MITRE Corporation. Common Weakness Enumeration. CWE 209. https://cwe.mitre.org/data/definitions/209.html. [3] The MITRE Corporation. CVE- 2008-2049. http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2049. [4] The MITRE Corporation. CVE-2004-0243. http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0243. [5] The MITRE Corporation. Common Weakness Enumeration. CWE 203. https://cwe.mitre.org/data/definitions/203.html. [6] “Re: sqwebmail web login.” [Online]. Available: https://marc.info/?l=bugtraq\u0026amp;m=107583269206044\u0026amp;w=2. [Accessed: Jan. 27, 2019]. [7] The MITRE Corporation. CVE-2004-1602. http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1602. [8] P. Laverty. “About User Enumeration.” [Online]. Available: https://blog.rapid7.com/2017/06/15/about-user-enumeration/ . [Accessed: Jan. 27, 2019]. [9] “ProFTPD 1.2.x remote users enumeration bug.” [Online]. Available: https://marc.info/?l=bugtraq\u0026amp;m=109786760926133\u0026amp;w=2. [Accessed: Jan. 27, 2019]. [10] Security Tracker. “ProFTPd Login Timing Differences Disclose Valid User Account Names to Remote Users.” [Online]. Available:https://securitytracker.com/id?1011687. [Accessed: Jan. 27, 2019] [11] The MITRE Corporation. CVE-2017-5753. http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5753. [12] The MITRE Corporation. CVE-2017-5715. http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5715. [13] P. Kocher, et al. \"Spectre attacks: Exploiting speculative execution.\" arXiv preprint arXiv:1801.01203 (2018). [14] D. Gruss. “Software-based Microarchitectural Attacks.” [Online]. Available: https://gruss.cc/files/oecg_2018.pdf . Pdf. [Accessed: Jan. 27, 2019]. [15] D. Feldman. “Timing is Everything: Understanding the Meltdown and Spectre Attacks.” [Online]. Available: https://hackernoon.com/timing-is-everything-understanding-the-meltdown-and-spectre-attacks-5e1946e44f9f .[Accessed: Jan. 27, 2019]. [16] Y. Yarom and K. Falkner. \"FLUSH+ RELOAD: A High Resolution, Low Noise, L3 Cache Side-Channel Attack,\" in 23rd USENIX Security Symposium, vol. 1, pp 719-732. 2014. [17] D. Gruss, R. Spreitzer, and S. Mangard. \"Cache Template Attacks: Automating Attacks on Inclusive Last-Level Caches,\" in 24th USENIX Security Symposium, pp. 897-912. 2015. [18] M. Lipp, D. Gruss, R. Spreitzer, C. Maurice, and S. Mangard, “ARMageddon: Cache Attacks on Mobile Devices,” in 25th USENIX Security Symposium, pp. 549-564. 2016. [19] Redhat. “Meltdown \u0026amp; Spectre -Kernel Side-Channel Attacks – CVE-2017-5754 CVE-2017-5753 CVE-2017-5715.” [Online]. Available: https://access.redhat.com/security/vulnerabilities/speculativeexecution. [Accessed: Jan. 27, 2019]. [20] P. Bright. “Spectre, Meltdown researchers unveil 7 more speculative execution attacks.” [Online]. Available: https://arstechnica.com/gadgets/2018/11/spectre-meltdown-researchers-unveil-7-more-speculative-execution-attacks/ . [Accessed: Jan. 27, 2019]. [21] “A Simplified Explanation of the ‘Meltdown’ CPU Vulnerability.” [Online]. Available: https://hackernoon.com/a-simplified-explanation-of-the-meltdown-cpu-vulnerability-ad316cd0f0de . [Accessed: Jan. 27, 2019]. [22] The MITRE Corporation. CVE-2017-5754. http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5754. [23] M. Lipp, et al. \"Meltdown: Reading kernel memory from user space,\" 27th USENIX Security Symposium (USENIX Security 18). Aug. 15-17, 2018, Baltimore, MD, United States. pp. 973-990. [24] Wikipedia. Meltdown (security vulnerability). https://en.wikipedia.org/wiki/Meltdown_(security_vulnerability). "},{"id":37,"href":"/BF/Old/Classes/IEX-Model/","title":"IEX Model","section":"Classes","content":"\rBF Model of Information Exposure\r#\rInformation and Data\r#\rThe terms data and information are often used interchangeably. Data is “a set of values of qualitative or quantitative variables” [1]. Information is “any entity or form that provides the answer to a question of some kind or resolves uncertainty\u0026quot; [2]. To what extent data is informative to someone depends on how unexpected it is to that person. A difference between data and information is that data has no meaning, while information has meaning. Information and data are on a continuum. Bits in memory are data. Without external context (meaning), the bits might represent an integer, an address, a set of flags or other low-level information. At a higher level, the integer could be someone’s age, the number of characters in a document, or a temperature. Typically, a person’s age is considered information, whereas “temperature” may be considered data, since it may be yesterday’s high temperature (where?) or the current temperature in a furnace. Without further meaning, it is unclear whether the temperature is in Centigrade, Fahrenheit, Kelvin, or something else!\nIn software, information is generated by processing data. [3] We distinguish between information that is sensitive and information that is not. Certain kinds of information can be indirectly sensitive: when revealed can lead to harmful consequences.\nIf sensitive information at rest in a file or a database is encrypted (see BF class ENC), then information cannot actually be exposed. If information is communicated outside the system via a secure channel, it cannot be exposed, either.\nSensitive information includes credentials, system data, state data, cryptographic data, digital documents, and personally identifiable and business data.\nCredentials include password, token, smart card, digital certificate, and biometrics, such as fingerprints, hand configuration, retina, iris, and voice characteristics. System data could be pathnames, configurations, logs, and Web usage. State data includes ooperational data, such as SQL table names and column names, ports used, and server names. Cryptographic data is hashes, keys, and keying material, such as cryptographic keys, initialization vectors, shared secrets, domain parameters, random seeds, salts, and nonces.\nPersonally identifiable data corresponds to personally identifiable information (PII) and personally identifiable financial information (PIFI). PII is any information that could be used to distinguish one person from another – e.g. social security number (SSN), driver’s license number, identification card number. PIFI includes financial account numbers with security codes/ access codes/ password. There is also protected health information, which includes a patient\u0026rsquo;s medical record or payment history, and payment card information, such as cardholder name, service code, expiration date, CVC2/ CVV2/ CID value, PIN or PIN block, content of magnetic stripe, etc.\nBusiness data covers intellectual property and trade secrets, operational and inventory data, and industry-specific data, in addition to customer and employee data.\nInformation Exposure Model\r#\rTo ground information exposure, we have developed a general model. “Exposure” is to any entity that should not have that information, not just information that is a security concern.\nFig. 1 presents our BF information exposure bugs model, showing through what channels software could expose information.\nFig 1. BF Model of Information Exposure - click on image for detailed view.\nInformation is stored on disks in files or in databases. Programs (source code and executables) are also stored on a disk in files and do not require any other resources. [4] A program is comprised of functions’ invocations. Most functions process input data into output information or data. However, some functions receive only control flow, e.g. to display information, error messages, dialogs; or to act on a global data value or when a state variable has changed or needs to be assessed. [5] A process is a program in execution and holds resources such as CPU, memory, disk, and input/output. A program can involve more than one process. [4] A session is a temporary, interactive information interchange between two or more devices, or between a computer and a user (e.g. login session). [6]\nInformation exposure may happen when either unintended information is carried, or an unintended recipient gets the information. The exposure may be accidentally or because of attacker’s actions.\nInformation could leak through legitimate channels during normal use of software. For example, via information display, via queries (including query strings in SQL queries and GET request), from hardcoded information (password, cryptographic key, etc.), class cloning, serializable classes, when public methods access private variables, inappropriate cleanup, or from session and process environments. Cleanup includes removing previously used information, buffer cleanup (dead store removal), and use of realloc``(). Sessions may leak information via session-ID length, sessions state boundaries, caching, and improper cleanup.\nA diagnostic channel, or error channel, is a legitimate channel that helps users and developers diagnose, find, and correct input or code errors. Information may be leaked via error messages, exception handling messages, or other responses to erroneous inputs or erroneous data processing. If an attacker forces and internal fault, it may divulge sensitive information, including details on the software implementation logic, to the attacker. [7]\nA side channel is not intended to transmit information; however, it does transmit information [8]. Information may be revealed or deduced due to discrepancies or behavioral inconsistencies. For example, conveying different responses (e.g. an operation is successful or not), taking different time (e.g. CPU timing), consuming different power, using different storage, or emitting different electromagnetic radiation. Behavioral inconsistency could be internal or external.\nA covert channel is a side channel that is created deliberately as a hidden communication channel [9]. Unfortunately, a covert channel may be created by optimization techniques, such as compiler optimizations [10] and speculative executions [11].\nIn a side channel, it is common for an attacker to control both the part that induces the side effect and the part that measures it [12, 13, 14]. In other cases, there\ncould be two collaborating attackers: an unauthorized user controlling the part that induces the side effect and a third party controlling the part that measures it. There could be also only a passive attacker, who observes an existing (not induced) behavioral inconsistency. Usually, statistical analysis of the measurements is involved. [15] describes creating covert channels using TCP/IP. Examples of side/covert attacks are Meltdown and Spectre [16], as well as the inference attacks [17].\nReferences\r#\r[1] Wikipedia. Data. https://en.wikipedia.org/wiki/Data.\n[2] Wikipedia. Information. https://en.wikipedia.org/wiki/Information.\n[3] TechDifference. “Difference Between Data and Information,” [Online]. Available: https://techdifferences.com/difference-between-data-and-information.html . [Accessed: Feb. 5, 2019].\n[4] TechDifference. “Difference Between Program and Process,” [Online]. Available: https://techdifferences.com/difference-between-program-and-process.html . [Accessed: Feb. 5, 2019].\n[5] ScienceDirect. “Software Function,” [Online]. Available: https://www.sciencedirect.com/topics/computer-science/software-function . [Accessed: Feb. 5, 2019].\n[6] Wikipedia. Session (computer science). https://en.m.wikipedia.org/wiki/Session_(computer_science) .\n[7] P. Anderson, “Common Embedded Vulnerabilities, Part 2: Information Leaks”, https://www.electronicdesign.com/embedded/common-embedded-vulnerabilities-part-2-information-leaks [Accessed: Jan. 30, 2019].\n[8] “Side Channels and Covert Channels”. [Online]. Available: http://ver.miun.se/courses/security/lectures/sidechannels.pdf. Pdf. [Accessed: Jan. 27, 2019].\n[9] Stack Exchange. “Covert, Overt, and side channels.” [Online]. Available: https://security.stackexchange.com/questions/113332/covert-overt-and-side-channels. [Accessed: Jan. 27, 2019].\n[10] Wikipedia. Category:Compiler optimizations. https://en.wikipedia.org/wiki/Category:Compiler_optimizations .\n[11] Wikipedia. Speculative execution. https://en.wikipedia.org/wiki/Speculative_execution .\n[12] M. Lipp, et al. \u0026ldquo;Meltdown: Reading kernel memory from user space,\u0026rdquo; 27th USENIX Security Symposium (USENIX Security 18). Aug. 15-17, 2018, Baltimore, MD, United States. pp. 973-990.\n[13] Wikipedia. Side-channel attack. https://en.wikipedia.org/wiki/Side-channel_attack.\n[14] D. Brumley and D. Boneh. \u0026ldquo;Remote timing attacks are practical.\u0026rdquo; Computer Networks 48, no. 5 (2005). Pp. 701-716.\n[15] “Covert Channels: How Insiders Abuse TCP/IP to Create Covert Channels,” Mar. 1, 2018. [Online]. Available: https://thecybersecurityman.com/2018/03/01/covert-channels-how-insiders-abuse-tcp-ip-to-create-covert-channels/. [Accessed: Jan. 27, 2019].\n[16] “Meltdown and Spectre.” [Online]. Available: https://meltdownattack.com, https://spectreattack.com. [Accessed: Jan. 27, 2019].\n[17] Wikipedia. Inference attack. https://en.wikipedia.org/wiki/Inference_attack.\n"},{"id":38,"href":"/BF/BF-Classes/_CRY/KMN/","title":"KMN","section":"Cryptographic Store and Transfer Bugs","content":"\rKey Management Bugs (KMN) Class\r#\rNote\nThis class is still under development. The information will be updated soon.\nDefinition\r#\rWe define Key Management Bugs (KMN) as follows:\nThe software does not properly generate, store, distribute, use, or destroy cryptographic keys and other keying material.\nSee also the Model of Cryptographic Store or Transfer.\nType\r#\rHigh (semantic).\nTaxonomy\r#\rFig. 1 depicts KMN causes, attributes and consequences.\nFig 1. Key Management Bugs (KMN) Class - click on image for detailed view.\nAttributes\r#\rCryptographic Data – Hashes, Keying Material, Digital Certificate.\nAlgorithm – Hash Function + RND, MAC, RSA, Digital Signature, etc.\nDifferent cryptosystems have their own specific algorithm(s).\nOperation – Generate/Select, Store, Distribute, Use, Destroy.\nThis is the failed operation. Store includes update and recover. Distribute includes key establishment, transport, agreement, wrapping, encapsulation, derivation, confirmation, shared secret creation; uses ENC and KMN (reclusively). KMN is a high level class, so sites do not apply.\nCauses\r#\rIEX of Key includes hardcoded key.\nSites\r#\rKMN is a high level class, so sites do not apply.\nRelated BF Classes\r#\rBF classes related to KMN are: ENC, RND, VRF, IEX.\nRelated CWEs and SFPs\r#\rCWEs related to KMN are CWE-321, CWE-322, CWE-323, CWE-324.\nThe related SFP clusters are: SFP 17.2 Weak Cryptography under Primary Cluster: Cryptography and SFP 4.13 Digital Certificate under Primary Cluster: Authentication. Note that, some of the CWEs listed in 17.2 are not KMN.\nBF Descriptions of KMN Related CWEs are provided here.\nApplication\r#\rApplication examples can be found here: CVE-2016-1919, CVE-2015-0204.\nReferences\r#\r[1] Bojanova, I., Black, P. E., Yesha, Y.,\rCryptography Classes in Bugs Framework (BF): Encryption Bugs (ENC), Verification Bugs (VRF), and Key Management Bugs (KMN). IEEE Software Technology Conference (STC 2017), NIST, Gaithersburg, USA. September 25-28, 2017.\n"},{"id":39,"href":"/BF/BF-Classes/_MEM/MAD/","title":"MAD","section":"Memory Bugs","content":"\rMemory Addressing Bugs (MAD) Class\r#\rDefinition\r#\rWe define Memory Addressing Bugs (MAD) as follows:\nThe pointer to an object is initialized, repositioned, or reassigned to an improper memory address. Taxonomy\r#\rFig. 1 depicts MAD causes, attributes and consequences.\nFig 1. Memory Addressing Bugs (MAD) Class - click on image for detailed view.\nOperations\r#\rThe MAD operations are: Initialize (Pointer), Reassign, Reposition. They reflect improper formation of an address.\nOperation Value Definition Initialize (pointer) The first assign of an object address to a pointer; positions the pointer at the start of the object. Reposition Changes the pointer to another position inside its object. Reassign Changes the pointer to a different object. Causes\r#\rThe graph of causes shows that there are three main causes for memory addressing bugs: Improper Operation, Improper Pointer, and Improper Object.\nImproper Operation Value Definition Missing The operation is absent. Mismatched The deallocation function does not match the allocation function used for the same object. Erroneous There is a bug in the implementation of the operation. Improper Pointer Value Definition NULL Pointer Points to the zero address, a specific invalid address. Wild Pointer Points to an arbitrary address, because it has not been initialized or an erroneous allocation routine is used. Dangling Pointer Still points to the address of its successfully deallo- cated object. Over Bounds Points over the bounds of its object. Under Bounds Points under the bounds of its object. Untrusted Pointer The pointer is modified to an improperly checked address. Wrong Position Points to a miscalculated position inside object bounds. Hardcoded Address The pointer points a wrong specific address. Casted Pointer The pointer does not match the type of the object, due to wrong type casting. Improper Object Value Definition Wrong Size Used The value used as size does not match the real size of the object. Not Enough Allocated The allocated memory is too little for the data it should store. Consequences\r#\rThe graph of consequences shows Improper Pointer for Next Operation as a consequence which means a MAD bug is always followed by another memory bug (such as MAL, MUS, MDL)\nImproper Pointer for Next Operation Value Definition NULL Pointer Points to the zero address, a specific invalid address. Wild Pointer Points to an arbitrary address, because it has not been initialized or an erroneous allocation routine is used. Dangling Pointer Still points to the address of its successfully deallo- cated object. Over Bounds Points over the bounds of its object. Under Bounds Points under the bounds of its object. Untrusted Pointer The pointer is modified to an improperly checked address. Wrong Position Points to a miscalculated position inside object bounds. Casted Pointer The pointer does not match the type of the object, due to wrong type casting. Forbidden Address The pointer points to an OS protected or non-existing address. Attributes\r#\rThe attributes of MAD are:\nName Value Definition Mechanism Direct The operation is performed over a particular object element. Sequential The operation is performed after iterating over the object elements. Source Code Codebase The operation is in programmer’s code – in the application itself. Third Party The operation is in a third party library. Standard Library The operation is in the standard library for a particular programming language. Language Processor The operation is in the tool that allows execution or creates executable (compiler, assembler, interpreter). Execution Space Userland The bugged code runs in an environment with privilege levels, but in unprivileged mode (e.g., ring 3 in x86 architecture). Kernel The bugged code runs in an environment with privilege levels with access privileged instruc- tions (e.g., ring 0 in x86 architecture). Bare-Metal The bugged code runs in an environment with-out privilege control. Usually, the program is the only software running and has total access to the hardware. Location Stack The object is a non-static local variable (defined in a function, a passed parameters, or a function return address). Heap The object is a dynamically allocated data structure (e.g., via malloc() and new). Sites\r#\rMAD sites are any changes to an owner via assignment (=) or repositioning via an index ([]) or pointer arithmetics (e.g., p++ and p--).\nApplication\r#\rApplication examples can be found here: CVE-2014-0160.\n"},{"id":40,"href":"/BF/BF-Classes/_RND/TRN/","title":"TRN","section":"Random Number Generation Bugs","content":"\rTrue-Random Number Bugs (TRN) Class\r#\rNote\nThis class is still under development. The information will be updated soon.\nDefinition\r#\rWe define True-Random Number Bugs (TRN) as:\nThe software generated output does not satisfy all use-specific true-randomness requirements.\nNote that the output sequence is of random bits, where values are obtained from one or more sources of entropy.\nSee also the BF Model of Cryptographic Store or Transfer.\nType\r#\rHigh (semantic).\nTaxonomy\r#\rFig. 1 depicts TRN causes, attributes and consequences.\nFig 1. True-Random Number Bugs (TRN) Class - click on image for detailed view.\nAttributes\r#\rFunction – Health Test, Conditioning, Mixing, Output, Converting.\nAlgorithm – Hash Function, Block Cipher, XOR, etc.\nUsed For –Seeding, Generation.\nThis is what the output sequence is used for. It could be used as a seed for a PRNG or for generation of passwords or cryptographic keying material (keys, nonces).\nRandomness Requirement –Sufficient Entropy, Sufficient Space Size, Non-Inferable.\nThis is the failed requirement.\nThe notion of entropy used here is min-entropy, as the negative logarithm of the probability of the most likely outcome. Let X be a random variable such that the set of possible values that it can have is finite. Let P be the set of probabilities of X having those values. The min-entropy of X is defined as –log2max(P), where max()finds the largest value in a set. The min-entropy is a measure of how difficult it is to guess the most likely entropy source output.\nSpace size is the number of elements of the space of possible outputs. If the number of different outputs is not sufficiently large, there is a vulnerability to a brute force attack. Non-inferable means one cannot recover from known (guessed) information anything about the TRBG output (CVE-2008-0141). TRBGs used for cryptography/security must satisfy the Non-Inferable randomness requirement.\nRelated BF Classes\r#\rBF classes related to PRN are: PRN, ENC, VRF, KMN, IEX.\nRelated CWEs and SFP\r#\rCWEs related to TRN are: CWE-330, CWE-331, CWE-332, CWE-333, CWE-334,\rCWE-337, CWE-339, CWE-340, CWE-341, CWE-342, CWE-343.\nThe only related SFP cluster is SFP Primary Cluster: Predictability.\nBF Descriptions of TRN Related CWEs are provided here.\nApplication\r#\rApplication examples can be found here: CVE-2008-0141.\nReferences\r#\r[1] Bojanova, I., Yesha, Y., Black, P. E., Randomness Classes in Bugs Framework (BF): True-Random Number Bugs (TRN) and Pseudo-Random Number Bugs (PRN). IEEE COMPSAC 2018, NII, Tokyo, Japan. July 23-27, 2018.\n"},{"id":41,"href":"/BF/Home/Why-BF/","title":"Why BF?","section":"BF Home","content":"\rWhy BF?\r#\rThe Bugs Framework aims to have the expressiveness power to clearly describe any software bug or weakness, underlying any vulnerability. It builds on the following commonly used repositories of software weaknesses and vulnerabilities, while considering the problems that they have.\nCommon Weakness Enumeration (CWE) – a community-developed list of software and hardware weaknesses types. Common Vulnerabilities and Exposures (CVE) – a catalog of publicly disclosed cybersecurity vulnerabilities. Over 18 000 were documented in 2020 only. National Vulnerabilities Database (NVD) – the US government repository that links all CVEs to CWEs. Repository Problems\r#\rCWE and CVE are widely used, but they have some problems. Many CWEs and CVEs have imprecise descriptions and unclear causality. CWE also has gaps and overlaps in coverage.\nThe following is an example of an imprecise CWE definition. CWE-502: Deserialization of Untrusted Data: The application deserializes untrusted data without sufficiently verifying that the resulting data will be valid.\nIt’s not clear here what “sufficiently” means. “Verifying that data is valid” is also confusing. It should say “\u0026hellip; without validating and verifying it”.\nUnclear causality in CVEs leads to wrong CWE assignments. For example, in this CVE, luck of input validation leads to integer overflow and then to buffer overflow. CVE-2018-5907: Possible buffer overflow in msm_adsp_stream_callback_put due to lack of input validation of user-provided data that leads to integer overflow in all Android releases (Android for MSM, Firefox OS for MSM, QRD Android) from CAF using the Linux kernel.\nNVD labels it with CWE-190 – Integer Overflow or Wraparound, while the cause is CWE-20 – Improper Input Validation.\nThe full chain is: CWE 20 – CWE 190 – CWE 119, the last one being – Improper Restriction of Operations within the Bounds of a Memory Buffer.\nGaps and overlaps in CWEs lead to confusion. As an example, if we arrange buffer overflow CWEs by read or write, over or under the bounds, on the stack or heap, the gaps and overlaps can be easily spotted. "},{"id":42,"href":"/BF/Home/Approach/","title":" Approach","section":"BF Home","content":"\rBF Approach\r#\rBF’s approach is different from CWE’s exhaustive list approach. BF is a classification. Each BF class is a taxonomic category of a weakness type. It relates to a distinct phase of software execution, the operations specific for that phase and the operands required as input to those operations.\nBF describes a bug or a weakness as an improper state and its transition. The transition is to another weakness or to a failure. An improper state is defined by the tuple (operation, operand1, ···, operandn), where at least one element is improper. The initial state is always caused by a bug; a coding error within the operation, which if fixed will resolve the vulnerability. An intermediate state is caused by ill-formed data; it has at least one improper operand. Rarely an intermediate state may also have a bug, which if fixed will also resolve the vulnerability. The final state, the failure, is caused by a final error (undefined or exploitable system behavior), which usually directly relates to a CWE. A transition is the result of the operation over the operands.\nBF describes a vulnerability as a chain of improper states and their transitions (see Fig. 1). Each improper state is an instance of a BF class. The transition from the initial state is by improper operation over proper operands. The transitions from intermediate states are by proper operations with at least one improper operand.\nFig 1. A vulnerability as a chain of weaknesses. - click on image for detailed view.\nOperations or operands improperness define the causes. A consequence is the result of the operation over the operands. It becomes the cause for a next weakness or a failure.\nA BF class is a taxonomic category of a weakness type, defined by:\nA set of operations All valid cause→consequence relations A set of attributes. The taxonomy of a particular bug or weakness is based on one BF class. Its description is an instance of a taxonomic BF class with one cause, one operation, one consequence, and their attributes. The operation binds the cause→consequence relation – e.g., deallocation via a dangling pointer leads to a failure known as double free.\n"},{"id":43,"href":"/BF/BF-Classes/_INP/DVR/","title":"DVR","section":"Input/Output Check Bugs","content":"\rData Verification Bugs (DVR) Class\r#\rDefinition\r#\rWe define Data Verification Bugs (DVR) as follows:\nData are verified (semantics check) or corrected (assign value, remove) improperly. Taxonomy\r#\rFig. 1 depicts DVR causes, attributes and consequences.\nFig 1. Data Verification Bugs (DVR) Class - click on image for detailed view.\nOperations\r#\rThe DVR operations are: Verify and Correct. They reflect the improper check and modification of data semantics.\nOperation Value Definition Verify Check data semantics (proper value/meaning) in order to accept (and possibly correct) or reject it. Correct Modify data (assign new value, remove), in order to make it accurate. Causes\r#\rThe graph of causes shows that there are two main causes for data verification bugs: Improper Operation and Improper Data.\nImproper Operation Value Definition Example Missing The operation is absent. Missing data sanitization. Erroneous There is a bug in the implementation of the operation (incl. how it checks against a policy). Using not equal to (!=) when comparing to safelist values. Using greater than (\u003e) when checking for upper range. Under-Restrictive Policy Accepts bad data. Permissive safelist or regular expression. Incomplete denylist. Over-Restrictive Policy Rejects good data. Over-restrictive denylist or regular expression. Improper Data Value Definition Invalid Data Data with harmed syntax due to sanitization errors. Consequences\r#\rThe graph of consequences shows Improper Data for Next Operation as a consequence.\nImproper Data for Next Operation Value Definition Invalid Data Data with harmed syntax due to sanitization errors. Wrong Value Data with harmed semantics; not accurate value (e.g., outside of a range). Inconsistent Value Data value is inconsistent with the value of a related data (e.g., inconstancy between the value of a size variable and the actual buffer size). Wrong Type Data with wrong data type. Attributes\r#\rThe attributes of DVR are:\nName Value Definition Mechanism Value Check data for a specific value (incl. NULL or list of values). Quantity Check data for a specific measurable value (e.g., size, time, rate, frequency). Range Check data are within a (min, max) interval. Type Check data type (e.g., int, float, XSD-XML Schema Definition, or specific structure/object). Other Rules Check data against other business logic. Source Code Codebase The operation is in programmer’s code – in the application itself. Third Party The operation is in a third party library. Standard Library The operation is in the standard library for a particular programming language. Language Processor The operation is in the tool that allows execution or creates executable (compiler, assembler, interpreter). Execution Space Local The bugged code runs in an environment with access control policy with limited (local user) permission. Admin The bugged code runs in an environment with access control policy with unlimited (admin user) permission. Bare-Metal The bugged code runs in an environment with-out privilege control. Usually, the program is the only software running and has total access to the hardware. State Entered Data comes from user interface (e.g., text field). Stored Data comes from permanent storage (e.g., file, database on a storage device). In Use Data comes from volatile storage (e.g., RAM, cache memory). Transferred Data comes via network (e.g., connecting analog device or another computer). Sites\r#\rA site for input/output check bugs is any part of the code that should check and sanitize data syntax or check and correct data semantics.\nApplication\r#\rApplication examples can be found here: CVE-2014-0160.\n"},{"id":44,"href":"/BF/Grammar/","title":"Grammar","section":"Overview","content":"\rBF Grammar\r#\rLL1 Grammar of the developed for now BF Clusters: _CRY, _DAT, _INP, _MEM\nSTART := Vulnerability Converge\nVulnerability:= Bug Operation OA_E\nOA_E := OperationAttribute OA_E | Error\nError := Fault FA_O | FinalError\nFA_O := FaultAttribute FA_O | Operation OA_E Converge:= Vulnerability Converge | Failure END\nBug := code_defect | specification_defect\ncode_defect := { Erroneous Code, Mismatched Operation, Missing Code, Wrong Code }\nspecification_defect := { Anonymous Scope, Inadequate Algorithm, Missing Modifier, Missing Qualifier, Modified Algorithm, Over-Restrictive Policy, Risky/Broken Algorithm, Under-Restrictive Policy, Weak Algorithm, Weak Protocol, Wrong Modifier, Wrong Qualifier, Wrong Scope }\nOperation := dcl_opr | dvl_opr | dvr_opr | enc_opr | kmn_opr | mad_opr | mal_opr | mdl_opr | mus_opr | nrs_opr | tcm_opr | tcv_opr | vrf_opr\ndcl_opr := { Declare, Define }\ndvl_opr := { Validate, Sanitize }\ndvr_opr := { Verify, Correct }\nenc_opr := { Encrypt, Decrypt }\nkmn_opr := { Generate/Select, Store, Distribute, Use, Destroy }\nmad_opr := { Initialize, Reposition, Reassign }\nmal_opr := { Allocate, Extend, Reallocate-Extend }\nmdl_opr := { Deallocate, Reduce, Reallocate-Reduce }\nmus_opr := { Initialize, Dereference, Read, Write, Clear }\nnrs_opr := { Refer, Call }\ntcm_opr := { Calculate, Evaluate }\ntcv_opr := { Cast, Coerce }\nvrf_opr := { Cryptographic Authenticate, Cryptographic Verify }\nOperationAttribute := execution_space | mechanism | source_code\nexecution_space := { Admin, Bare-Metal, Kernel, Local, Userland }\nmechanism := { Ad-hoc Bind, Asymmetric Algorithm, Bind, Data Type, Denylist, Digital Signature, Direct, Early Bind, Explicit, Format, Function, Generics, Hash Function + Random Numbers, Implicit, Lambda Expression, Late Bind, Length, Message Authentication Code (MAC), Method, Operator, Other Rules, Overloading, Overriding, Pass In, Pass Out, Procedure, Quantity, Range, Resolve, Safelist, Sequential, Simple, Symmetric Algorithm, Value }\nsource_code := { Codebase, Compiler/Interpreter, Standard Library, Third Party }\nFault := address_fault | data_fault | name_fault | size_fault | type_fault\naddress_fault := { Dangling Pointer, NULL Pointer, Over Bounds Pointer, Under Bounds Pointer, Untrusted Pointer, Wild Pointer, Wrong Position Pointer }\ndata_fault := { Corrupted Data, Corrupted Policy Data, Distorted Value, Flipped Sign, Forbidden Address, Forged Signature, Hardcoded Address, Hardcoded Key, Inconsistent Value, Meaningless Data, Over Range, Reference vs. Object, Rounded Value, Single Owned Address, Tampered Data, Tampered Policy Data, Truncated Value, Under Range, Unverified Data, Unverified Key, Unverified Other Keying Material, Weak Cyphertext, Weak Key, Weak Other Keying Material, Wrap Around, Wrong Argument, Wrong Index, Wrong Result, Wrong Size Used, Wrong Value }\nname_fault := { Missing Overloaded Function, Missing Overridden Function, Wrong Function Resolved, Wrong Generic Function Bound, Wrong Object Resolved, Wrong Object Type Resolved, Wrong Overloaded Function Bound, Wrong Overridden Function Bound }\nsize_fault := { Not Enough Memory Allocated }\ntype_fault := { Casted Pointer, Confused Subtype, Incomplete Type, Invalid Data, Mismatched Argument, Wrong Argument Type, Wrong Generic Type, Wrong Index Type, Wrong Object Type Resolved, Wrong Type, Wrong Type Resolved }\nFinalError := access | data_security | injection | memory | type_compute\naccess := { Wrong Access Function, Wrong Access Object, Wrong Access Type }\ndata_security := { Revealed Key, Revealed Other Keying Material, Revealed Plaintext }\ninjection := { Command Injection, File Injection, Parameter Injection, Query Injection, Source Code Injection }\nmemory := { Buffer Overflow, Buffer Underflow, Double Free, Memory Leak, Memory Overflow, Not Cleared Object, NULL Pointer Dereference, Object Corruption, Type Confusion, Uninitialized Object, Uninitialized Pointer Dereference, Untrusted Pointer Dereference, Use After Free }\ntype_compute := { Undefined }\n==============================================================================\nAll Clusters: _CRY, _DAT, _INP, _MEM\nAll Classes: DCL, DVL, DVR, ENC, KMN, MAD, MAL, MDL, MUS, NRS, TCM, TCV, VRF\nAll Bugs: Anonymous Scope, Erroneous Code, Inadequate Algorithm, Mismatched Operation, Missing Code, Missing Modifier, Missing Qualifier, Modified Algorithm, Over-Restrictive Policy, Risky/Broken Algorithm, Under-Restrictive Policy, Weak Algorithm, Weak Protocol, Wrong Code, Wrong Modifier, Wrong Qualifier, Wrong Scope\nAll Operations: ACE Operation, Allocate, Calculate, Call, Cast, Clear, Coerce, Correct, Cryptographic Authenticate, Cryptographic Verify, Deallocate, Declare, Decrypt, Define, Dereference, Destroy, Distribute, DOS Operation, Encrypt, Evaluate, Extend, Generate/Select, IEX Operation, IMP Operation, Initialize, Read, Reallocate-Extend, Reallocate-Reduce, Reassign, Reduce, Refer, Reposition, Sanitize, Store, Use, Validate, Verify, Write\nAll Operation Attrubutes: Ad-hoc Bind, Admin, Asymmetric Algorithm, Bare-Metal, Bind, Codebase, Compiler/Interpreter, Data Type, Denylist, Digital Signature, Direct, Early Bind, Explicit, Format, Function, Generics, Hash Function + Random Numbers, Implicit, Kernel, Lambda Expression, Late Bind, Length, Local, Message Authentication Code (MAC), Method, Operator, Other Rules, Overloading, Overriding, Pass In, Pass Out, Procedure, Quantity, Range, Resolve, Safelist, Sequential, Simple, Standard Library, Symmetric Algorithm, Third Party, Userland, Value\nAll Faults: Casted Pointer, Confused Subtype, Corrupted Data, Corrupted Policy Data, Dangling Pointer, Distorted Value, Flipped Sign, Forbidden Address, Forged Signature, Hardcoded Address, Hardcoded Key, Incomplete Type, Inconsistent Value, Invalid Data, Meaningless Data, Mismatched Argument, Missing Overloaded Function, Missing Overridden Function, Not Enough Memory Allocated, NULL Pointer, Over Bounds Pointer, Over Range, Reference vs. Object, Rounded Value, Single Owned Address, Tampered Data, Tampered Policy Data, Truncated Value, Under Bounds Pointer, Under Range, Untrusted Pointer, Unverified Data, Unverified Key, Unverified Other Keying Material, Weak Cyphertext, Weak Key, Weak Other Keying Material, Wild Pointer, Wrap Around, Wrong Argument, Wrong Argument Type, Wrong Function Resolved, Wrong Generic Function Bound, Wrong Generic Type, Wrong Index, Wrong Index Type, Wrong Object Resolved, Wrong Object Type Resolved, Wrong Overloaded Function Bound, Wrong Overridden Function Bound, Wrong Position Pointer, Wrong Result, Wrong Size Used, Wrong Type, Wrong Type Resolved, Wrong Value\nAll Fault Attrubutes: /other/, Boolean, Credentials, Cryptographic, Data Type, Digital Certificate, Digital Document, Entered, Function, Hashes, Heap, Huge, In Use, Keying Material, Litle, Moderate, Namespace, None, Numeric, Object, Pointer, Primitive, Private, Public, Secret, Shared, Single, Stack, State, Stored, Structure, System, Text, Transferred, User Entered\nAll Final Errors: Buffer Overflow, Buffer Underflow, Command Injection, Double Free, File Injection, Memory Leak, Memory Overflow, Not Cleared Object, NULL Pointer Dereference, Object Corruption, Parameter Injection, Query Injection, Revealed Key, Revealed Other Keying Material, Revealed Plaintext, Source Code Injection, Type Confusion, Undefined, Uninitialized Object, Uninitialized Pointer Dereference, Untrusted Pointer Dereference, Use After Free, Wrong Access Function, Wrong Access Object, Wrong Access Type\n"},{"id":45,"href":"/BF/Old/Classes/IEX/","title":"IEX","section":"Classes","content":"\rInformation Exposure (IEX) Class\r#\rDefinition\r#\rWe define Information Exposure (IEX) as:\nInformation is leaked through legitimate or side channels. Note that leakage to an entity that should not have information is included, not just leakage that is a security concern.\nType\r#\rHigh (semantic).\nTaxonomy\r#\rFig. 1 depicts IEX causes, attributes and consequences.\nFig 1. Information Exposure (IEX) Class - click on image for detailed view.\nAttributes\r#\rThe attributes of IEX are:\nInformation– Credentials, System Data, State Data, Cryptographic Data, Digital Documents, Personally Identifiable Data, Business Data, etc.\nSensitivity – High, Low.\nThis indicates the sensitivity level of leaked information. Highly sensitive information that is encrypted, or information that is non-sensitive would not result in harm if and exposed. Non-sensitive information includes public records, phone books, or online directories.\nInformation State – Stored, Used, Transferred.\nThis reflects if the information is in rest, in use, or in transit. Information can be in rest in files (e.g. ini, temp, configuration, log server, debug, cleanup, email attachment, login buffer, executable, backup, core dump, access control list, private data index), directories (Web root, FTP root, CVS repository), or on discs. Information can be in use by functions/programs \u0026ndash; source code (incl. comments); threads, registries, cookies, GUI, environmental variables. Data can be also in transit between processes or over a network.\nInformation Size – Little, Some, Huge.\nThis indicates how much information is leaked.\nThese distinctions are important in some cases. For instance, Heartbleed [2] might not have been a severe problem if it just exfiltrated a little data. The fact that it may exfiltrate a huge amount of data greatly increases the chance that very important information will be leaked.\nExposure – Selective, Random.\nThis reflects if an attacker can choose what information to expose or where. Selective means the attacker can choose where and what to read. Random is like going through the trash (e.g. Heartbleed [2]).\nFrequency – Once, On-demand, On-timing, Rare, Often, Fast.\nThis indicates how often the exposure can/does occur. On-timing means depending on timing (e.g. in race condition). Note that Frequency * Size = Rate.\nChannel– Legitimate, Diagnostic, Side, Covert.\nThis indicates the medium by which information was leaked.\nUse – Direct, Indirect**.**\nDirect means leaked information is valuable on its own. Indirect means it is only useful for launching other attacks.\nCauses\r#\rIn the graph of causes, Uncleared Before Release means information going from one control sphere back to the general pool. Cross-Boundary Removal means information going from one control sphere to another control sphere. A control sphere is a set of resources and behaviors that are accessible to a single actor or a group of actors that all share the same security restrictions.\nProtect Sensitive Data also covers preparing sensitive data.\nSoftware/Hardware Behavior covers algorithms and execution. Observable behavior (time, power, cache lines) depends on the data.\nImproper Details include passwords, paths, SQL query structure/logic, etc. in error/exception, etc. messages.\nENC includes failure to encrypt (cleartext storage, recoverable format storage, cleartext transmission) and failure to properly encrypt (inadequate encryption strength, use of risky/broken cryptographic algorithm, missing required cryptographic step, use of hard-coded cryptographic key).\nATN/AUT includes improper authentication, credentials compromise, account access.\nINJ includes adding commands and masking legitimate commands or information.\nCIF is control of interaction frequency, including limiting the number of failed log in attempts. If there is no limit on the number of attempts, account names or passwords may be discovered by brute force attacks.\nConsequences\r#\rOne information exposure (IEX) fault may lead to another information exposure. For instance, an information exposure of all client credit cards may have been caused by earlier obtaining the password for a privileged account.\nRelated BF Classes\r#\rBF classes related to IEX are: BOF, INJ, CIF, ENC, VRF, KMN, TRN, PRN.\nRelated CWEs and SFP\r#\rCWEs related to IEX are: CWE-8, CWE-11, CWE-13\r, CWE-200, CWE-201, CWE-202, CWE-203, CWE-204, CWE-205, CWE-206, CWE-207, CWE-208\r, CWE-209, CWE-210, CWE-211, CWE-212, CWE-213, CWE-214, CWE-215, CWE-226, CWE-244, CWE-260, CWE-359, CWE-377, CWE-385, CWE-402, CWE-403, CWE-433\r, CWE-488, CWE-492, CWE-495, CWE-497, CWE-498, CWE-499, CWE-524, CWE-514, CWE-515, CWE-525, CWE-527, CWE-528, CWE-529, CWE-530, CWE-532, CWE-535\r, CWE-536, CWE-537, CWE-538, CWE-539, CWE-540, CWE-541,\rCWE-546, CWE-548, CWE-550, CWE-552, CWE-555, CWE-598, CWE-612, CWE-615, CWE-642, CWE-651, CWE-668.\nThere are many related CWEs because information exposure can be the consequence of many weaknesses.\nThe only related SFP cluster is SFP Primary Cluster: Information Leak.\nBF Descriptions of IEX Related CWEs are provided here.\nApplication\r#\rApplication examples are provided here.\nReferences\r#\r[1] I. Bojanova, P. E. Black, Y. Yesha, and Y. Wu, “The Bugs Framework (BF): A Structured approach to express bugs”, Proceedings of IEEE International Conference on Software Quality, Reliability and Security (QRS), 2016, , pp. 175-182.\n[2] “The Heartbleed Bug.” [Online]. Available: http://heartbleed.com/.\n[3] Common Weakness Enumeration. “CWE Glossary.” [Online]. Available: https://cwe.mitre.org/documents/glossary/index.html#ControlSphere.\n"},{"id":46,"href":"/BF/Old/Examples/INJ/","title":"INJ","section":"Examples","content":"\rInjection (INJ) Examples\r#\rCVE 2007-3572 (Yoggie Pico) BF Taxonomy Cause: Input not checked properly (incomplete blacklist) Attributes: Language: CGI Special Element: Shell Metacharacters (back ticks `) Entry Point: Function Parameter (\"param\") Invalid Construct: Command (command within a Ping command) Consequence: Add command, leading to arbitrary code execution and potentially complete host takeover (by adding a Ping command to change the root password) BF Description \"Input not checked properly (incomplete blacklist) allows Shell metacharacters (back ticks `( through a function parameter (\"param\") in a CGI script and assembly of a string that is parsed into an invalid command construct (command within a Ping command), which may be exploited to add command, leading to arbitrary code execution and potentially complete host takeover (by adding a Ping command to change the root password).\" [2] This is a shell command injection CVE Description \"Incomplete blacklist vulnerability in cgi-bin/runDiagnostics.cgi in the web interface on the Yoggie Pico and Pico Pro allows remote attackers to execute arbitrary commands via shell metacharacters in the param parameter, as demonstrated by URL encoded \"`\" (backtick) characters (%60 sequences).\" [1] Analysis The following analysis is based on information in [1,3,4]. Injecting backticks that are not sanitized enables adding a shell command in a CGI script. Complete Host takeover is possible by using backtick to execute changing the file /etc/shadow to include an arbitrary password selected by the attacker. Then the attacker can use that password to login as root. The Ping command was not expected to include a \"command within a (Ping) command\", but the backticks (special elements) result in that unexpected structure. Source Code Code With Bug Code With Fix Source Code Not Available Source Code Not Available CVE-2008-5817 BF Taxonomy Cause: Input not checked properly or input not sanitized properly Attributes: Language: SQL Special Element: Query Elements (single quote ' , the word or, and equality sign =) Entry Point: Data Entry Fields (\"username\" \u0026 \"password\") Invalid Construct: Database Query Consequence: Authentication loss, admin server access, and arbitrary code execution BF Description \"Input not checked properly or input not sanitized properly allows query elements (single quote ' , the word or, and equality sign =) through data entry fields (\"username\" \u0026 \"password\") in a PHP script and assembly of a string that is parsed into an invalid database query construct, which may be exploited to mask legitimate SQL commands, leading to authentication loss, admin server access, and arbitrary code execution. [2] This is SQL Injection CVE Description \"Multiple SQL injection vulnerabilities in index.php in Web Scribble Solutions webClassifieds 2005 allow remote attackers to execute arbitrary SQL commands via the (1) user and (2) password fields in a sign_in action.\" [5] Analysis The following analysis is based on information in [5,6,7]. According to [7], ' or ' 1=1 is used to mask password checking and login as admin. [8] includes an explanation of this type of SQL injection. Source Code Code With Bug Code With Fix Source Code Not Available Source Code Not Available CVE-2008-5734 BF Taxonomy Causes: Input not checked properly (incomplete blacklist) or input not sanitized properly Attributes: Language: HTML Special Element: Scripting Elements ('\u0026lt;','\u0026lt;/','\u0026gt;') Entry Point: Markup Tag (\u0026lt;IMG\u0026gt;) Argument (SRC) Invalid Construct: Markup (IMG element with \u0026lt;script\u0026gt; ... \u0026lt;/script\u0026gt; in it) Consequence: Add commands or credentials compromise for cookie-based authentication, leading to arbitrary code execution BF Description \"Input not checked properly (incomplete blacklist) or input not sanitized properly allows HTML scripting elements ('\u0026lt;','\u0026lt;/','\u0026gt;') through a markup tag (\u0026lt;IMG\u0026gt;) argument (SRC) of a generated HTML email and assembly of a string that is parsed into an invalid markup construct (IMG element with \u0026lt;script\u0026gt; ... \u0026lt;/script\u0026gt; in it), which may be exploited to add commands or credentials compromise for cookie-based authentication, leading to arbitrary code execution.\" [2] This is XSS web script or HTML injection. CVE Description \"Cross-site scripting (XSS) vulnerability in WebMail Pro in IceWarp Software Merak Mail Server 9.3.2 allows remote attackers to inject arbitrary web script or HTML via an IMG element in an HTML e-mail message.\" [9] Analysis The following analysis is based on information in [9,10,11]. According to [10], one of the several consequences is unauthorized access to cookie-based authentication credentials. Source Code Code With Bug Code With Fix Source Code Not Available Source Code Not Available References [1] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2007-3572. [2] Irena Bojanova, Paul E. Black, Yaacov Yesha, and Yan Wu, The Bugs Framework (BF): A Structured Approach to Express Bugs, QRS 2016, Vienna, Austria. [3] The MITRE Corporation, CWE Common Weakness Enumeration, CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'). [4] Yoggie Pico Pro Remote Code Execution [5] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2008-5817. [6] CXSESECURITY, webClassifieds 2005 (Auth Bypass) SQL Injection Vulnerability CWE-89 CVE-2008-5817. [7] The MITRE Corporation, CWE Common Weakness Enumeration, CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'). [8] Bricks, SQL injection. [9] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2008-5734. [10] SecurityFocus, Merak Mail Server and Webmail Email Message HTML Injection Vulnerability. [11] The MITRE Corporation, CWE Common Weakness Enumeration, CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'). "},{"id":47,"href":"/BF/BF-Classes/_MEM/MAL/","title":"MAL","section":"Memory Bugs","content":"\rMemory Allocation Bugs (MAL) Class\r#\rDefinition\r#\rWe define Memory Allocation Bugs (MAL) as follows:\nAn object is allocated, extended, or reallocated (while extending) improperly. Taxonomy\r#\rFig. 1 depicts MAL causes, attributes and consequences.\nFig 1. Memory Allocation Bugs (MAL) Class - click on image for detailed view.\nOperations\r#\rThe MAL operations are: Allocate, Extend, and Reallocate–Extend. They reflect improper formation of an object.\nOperation Value Definition Allocate Reserves space in memory for an object; defines its initial boundaries and size. Extend Allocates additional memory for an object in the same space; redefines its boundaries and size. Reallocate–Extend Allocates a new larger piece of memory for an object at a new address, copies the object content there, reassigns its pointer, and deallocates the previous piece of memory. Causes\r#\rThe graph of causes shows that there are three main causes for memory allocation bugs: Improper Operation, Improper Pointer, and Improper Object.\nImproper Operation Value Definition Missing The operation is absent. Mismatched The deallocation function does not match the allocation function used for the same object. Erroneous There is a bug in the implementation of the operation. Improper Pointer Value Definition Wild Pointer Points to an arbitrary address, because it has not been initialized or an erroneous allocation routine is used. Dangling Pointer Still points to the address of its successfully deallo- cated object. Wrong Position Points to a miscalculated position inside object bounds. Hardcoded Address The pointer points a wrong specific address. Forbidden Address The pointer points to an OS protected or non-existing address. Single Owner of Object The only pointer of an already allocated object is used to allocate a new object. Improper Object Value Definition Wrong Size Used The value used as size does not match the real size of the object. Consequences\r#\rThe graph of consequences shows Improper Pointer for Next Operation, Improper object for Next Operation, and Memory Error as consequences.\nImproper Pointer for Next Operation Value Definition NULL Pointer Points to the zero address, a specific invalid address. Wild Pointer Points to an arbitrary address, because it has not been initialized or an erroneous allocation routine is used. Improper Object for Next Operation Value Definition Not Enough Allocated The allocated memory is too little for the data it should store. Memory Error Value Definition Memory Overflow More memory requested than available. Memory Leak An object has no pointer pointing to it. Double Free Attempt to deallocate a deallocated object or via an uninitialized pointer. Object Corruption Object data is unintentionally altered. Attributes\r#\rThe attributes of MAL are:\nName Value Definition Mechanism Implicit The operation is performed without a function call. Explicit The operation is performed by a function/ method) call. Source Code Codebase The operation is in programmer’s code – in the application itself. Third Party The operation is in a third party library. Standard Library The operation is in the standard library for a particular programming language. Language Processor The operation is in the tool that allows execution or creates executable (compiler, assembler, interpreter). Execution Space Userland The bugged code runs in an environment with privilege levels, but in unprivileged mode (e.g., ring 3 in x86 architecture). Kernel The bugged code runs in an environment with privilege levels with access privileged instruc- tions (e.g., ring 0 in x86 architecture). Bare-Metal The bugged code runs in an environment with-out privilege control. Usually, the program is the only software running and has total access to the hardware. Ownership None The object has no owner. Single The object has one owner. Shared The object has more than one owner. Location Stack The object is a non-static local variable (defined in a function, a passed parameters, or a function return address). Heap The object is a dynamically allocated data structure (e.g., via malloc() and new). Sites\r#\rMAL sites are any allocation routine (e.g., malloc()) or the new operator, any declaration of a variable with implicit allocation, any OOP constructor, or any extension routine (e.g., realloc()) or adding elements to a container object.\nApplication\r#\rApplication examples can be found here: CVE-2021-21834.\n"},{"id":48,"href":"/BF/BF-Classes/_DAT/NRS/","title":"NRS","section":"Data Type Bugs","content":"\rName Resolution Bugs (NRS) Class\r#\rDefinition\r#\rWe define Name Resolution Bugs (NRS) as follows:\nThe name of an object, a function, or a data type is resolved improperly or bound to an improper data type or implementation. Taxonomy\r#\rFig. 1 depicts NRS causes, attributes and consequences.\nFig 1. Name Resolution Bugs (NRS) Class - click on image for detailed view.\nOperations\r#\rThe NRS operations are: Refer and Call. They reflect the improper name resolution, and data type, data, or implementation binding. Operation Value Definition Refer Use a name in local or remote scopes of source code. The Type System resolves the name and binds a data type to it. Call Invoke a function implementation. The Type System binds the implementation to the resolved function name. A polymorphic implementation is first resolved and then bound. Causes\r#\rThe graph of causes shows that there are three main causes for name resoultion bugs: Improper Operation, Improper Scope, Improper DataType, and Improper Function.\nImproper Operation Value Definition Examples Erroneous The Type System or a compute function implementation has a bug. Incorrect data type inference. Wrong order or number of arguments to a function call. Incorrect deep objects comparison implementation. Operands Concept Definition Data Value A numeric, text, pointer/address, or boolean value stored in an object’s memory. Data Type A set of allowed values and the operations allowed over them. Function An organized block of code that when called takes in data, processes it, and produces a result(s). Consequences\r#\rThe graph of consequences shows Improper Data Value, Improper Data Type, and Improper Function.\nImproper Data Value Concept Definition Under Range Data value is smaller than type’s lower range. Over Range Data value is larger than type’s upper range. Flipped Sign Sign bit is overwritten from type related calculation. Wrong Argument Value Inaccurate input data value; i.e., non-verified for harmed semantics. Wrong Object Resolved Value Object is resolved from wrong scope. Reference vs. Object Object’s address instead of object’s data value. Wrong Result Incorrect value from type conversion or computation. Wrap Around A moved around-the-clock value over its data type upper or lower range, as it exceeds that range. (Integer Over-/Under-flow is a wrapped-around the upper/lower range integer value; may become very small/large and change to the opposite sign.) Truncated Value Rightmost bits of value that won’t fit type size are cut off. Distorted Value Incorrect value (although fits type size) due to sign flip or signed/unsigned and vice versa conversions. Rounded Value Real number value precision loss. Improper Data Type Concept Definition Wrong Type Data type range or structure is not correct. Wrong Type Resolved Data type is resolved from wrong scope. Wrong Object Resolved Type Object is resolved from wrong scope,so it’s data type might be wrong. Wrong Sign Type Unsigned instead of signed data type is specified or vise versa. Wrong Precision Type Higher precision data type is needed (e.g. double instead of float). Incomplete Type Specific constructor, method, or overloaded function is missing. Mismatched Argument Type Argument’s data type is different from function’s parameter data type. Wrong Generic Type Generic object instantiated via wrong type argument. Confused Subtype Object invoking an overriden function is of wrong subtype data type. Wrong Argument Type Argument to an overloaded function is of wrong data type. Improper Function Concept Definition Missing Overridden Function Function implementation in a particular subclass is absent. Missing Overloaded Function Implementation for particular function parameters’ data types is absent. Wrong Function Resolved Function is resolved from wrong scope. Wrong Generic Function Bound Implementation for a wrong data type is bound due to wrong generic type arguments. Wrong Overridden Function Bound Implementation from wrong subtype is bound due to a wrong invoking subtype object. Wrong Overloaded Function Bound Wrong overloaded implementation is bound due to wrong function arguments. Attributes\r#\rThe attributes of NRS are: Name Value Definition Source Code Codebase The operation is in programmer’s code – in the application itself. Third Party The operation is in a third party library. Standard Library The operation is in the standard library for a particular programming language. Compiler/Interpreter The operation is in the language processor that allows execution or creates executables (compiler, assembler, interpreter). Data Type Kind Primitive Mimics the hardware units and is not built from other data types – e.g. int (long, short, signed), float, double, string, boolean. Structured Builds of other data types; have members of primitive and/or structured data types – e.g. array, record, struct, union, class, interface. Mechanism Resolve Look up entity name and if needed determine data type (infer from value, through hierarchy, via generic type attribute). Bind Connect object data type, function return type, parameter data type, or simple function imple- mentation. Early Bind Resolve subtype and set generic function imple- mentation. Late Bind Resolve overriden function via subtype object and set implementation. Ad-hoc Bind Resolve overloaded function via signature and set implementation. Entity Object A memory region used to store data. Function An organized block of code that when called takes in data, processes it, and returns a result. Data Type A set or a range of values and the operations allowed over them. Namespace An organization of entities’ names, utilized to avoid names collision. Sites\r#\rNRS sites are the entities references and the function calls.\nApplication\r#\rApplication examples can be found here: CVE-2021-21834, CVE-2021-23440, CWE-468.\n"},{"id":49,"href":"/BF/BF-Classes/_CRY/VRF/","title":"VRF","section":"Cryptographic Store and Transfer Bugs","content":"\rVerification Bugs (VRF) Class\r#\rNote\nThis class is still under development. The information will be updated soon.\nDefinition\r#\rWe define Verification Bugs (VRF) as follws:\nThe software does not properly sign data, check and prove source, or assure data is not altered.\nNote that \u0026ldquo;check\u0026rdquo; is for identity authentication, \u0026ldquo;prove\u0026rdquo; is for origin (signer) non-repudiation, and \u0026ldquo;not altered\u0026rdquo; is for integrity authentication.\nSee also the Model of Cryptographic Store or Transfer.\nType\r#\rHigh (semantic).\nTaxonomy\r#\rFig. 1 depicts VRF causes, attributes and consequences.\nFig 1. Verification Bugs (VRF) Class - click on image for detailed view.\nAttributes\r#\rVerified Data – Secret, Public.\nThis is the data that needs verification. It may be confidential or public. Secret (confidential) data could be cryptographic hashes, secret keys, or keying material. Public data could be signed contract, documents, or public keys.\nAlgorithm – Hash Function + PRN, Message Authentication Code (MAC), Digital Signature.\nHash functions are used for integrity authentication. They may use PRN. MAC are symmetric key algorithms (one secret key per source/user), used for integrity authentication, identity authentication. It needs authentication code generation, source signs data, user gets tag for key and data, and verifies data by tag and key. Digital Signature is an asymmetric key algorithm (two keys), used for integrity and identity authentication, and origin (signer) non-repudiation. It needs key generation, signature generation, and signature verification. MAC and Digital Signature use KMN and recursively VRF.\nSecurity Service – Data Integrity Authentication, Identity Authentication, Origin (Signer) Non-Repudiation.\nThis is the security service the verification process failed. Integrity Authentication is for data and keys. Identity Authentication and Origin Non-Repudiation are for source authentication.\nCauses\r#\rWeak key is a KMN fault.\nSites\r#\rVRF is a high level class, so sites do not apply.\nRelated BF Classes\r#\rBF classes related to VRF are: KMN, RND, ENC, ATN, IEX.\nRelated CWEs and SFPs\r#\rCWEs related to Verification (although some are not VRF) are: CWE-256, CWE-293, CWE-295, CWE-296, CWE-297, CWE-347, CWE-352.\nThe related SFP cluster is SFP 17.2 Weak Cryptography under Primary Cluster: Cryptography\nBF Descriptions of VRF Related CWEs are provided here.\nApplication\r#\rApplication examples can be found here: CVE-2001-1585, CVE-2015-2141.\nReferences\r#\r[1] Bojanova, I., Black, P. E., Yesha, Y., Cryptography Classes in Bugs Framework (BF): Encryption Bugs (ENC), Verification Bugs (VRF), and Key Management Bugs (KMN). IEEE Software Technology Conference (STC 2017), NIST, Gaithersburg, USA. September 25-28, 2017.\n"},{"id":50,"href":"/BF/Old/Classes/INJ/","title":"INJ","section":"Classes","content":"\rInjection (INJ) Class\r#\rDefinition\r#\rWe define Injection (INJ) as:\nDue to input with language-specific special elements, the software assembles a command string that is parsed into an invalid construct. In other words, the command string is interpreted to have unintended, queries, OS commands, markups, scripts, etc.\nType\r#\rHigh (semantic).\nTaxonomy\r#\rFig. 1 depicts INJ causes, attributes and consequences.\nFig 1. Injection (INJ) Class - click on image for detailed view.\nAttributes\r#\rThe attributes of INJ are:\nLanguage – SQL, Bash, regex, XML/Xpath, PHP, CGI, etc.\nThis indicates the language in which the command string is interpreted.\nSpecial Element – Query Elements, Header Separators, Scripting Elements, Format Parameters, Path Traversals, Wildcards, Metacharacters, etc.\nThese could be assembled with other elements to form malicious structures such as queries, scripts and commands. Query elements are strings delimiters ‘ or “ or words such as and or or. Header separators are carriage return/line feed. Scripting elements are \u0026lt; or \u0026gt; or \u0026amp;. Format parameters are such as %c or %n. Path traversals elements are .. or \\. Metacharacters are back tick (`) or $ or \u0026amp;.\nEntry Point – Data Entry Field, Scripting Tag, Markup Tag, Function Call Parameter, Procedure Call Argument, Program Argument, System Property, Cookie, etc.\nThis indicates where the input came from.\nInvalid Construct – Database Query, OS Command, Regular Expression, Markup, Script, etc.\nThis indicates what eventually is wrong.\nCauses\r#\rThe graph of causes shows that there are two main causes for injection: input not checked properly or input not sanitized properly.\nConsequences\r#\rIn the graph of consequences, Arbitrary Code Execution concerns any instructions to the computer – compiled, interpreted by software, executed directly by hardware or combination.\nNote that INJ can cause Information Change/Loss. For example, and attacker can inject a command (Add Command) that overwrites a file.\nAn example of Mask Legitimate Command is inserting “--”, which would comment part of that legitimate command. An example of Mask Legitimate Information is inserting “or 1==1”, which would change a password to an expression that returns always true.\nSites\r#\rInjection sites are typically not primitive operations in most languages. Sites are the library or utility functions that accept a command string for actions. In shell commands, command substitution is invoked with paired back quotes (`...`) or $(...). Command substitution executes a subshell, which opens the possibility of the string to be interpreted with all the richness of the command line interpreter.\nRelated BF Classes\r#\rBF classes related to INJ are: ATN, \u0026lt;\u0026lt;content to be added\u0026gt;\u0026gt;.\nRelated CWEs, SFPs and ST\r#\rCWEs related to INJ are: CWE-59, CWE-74, CWE-75, CWE-77, CWE-78, CWE-79, CWE-80, CWE-85, CWE-87, CWE-88, CWE-89, CWE-90, CWE-91, CWE-93, CWE-94, CWE-99, CWE-113, CWE-116, CWE-172, CWE-243, CWE-395, CWE-564, CWE-611, CWE-619, CWE-643, CWE-652, CWE-943.\nThe corresponding ST is the Injection Semantic Template.\nBF Descriptions of INJ Related CWEs are provided here.\nApplication\r#\rApplication examples are provided here.\nReferences\r#\r[1] Bojanova, I., Black, P. E., Yesha, Y., Wu, Y.,\rThe Bugs Framework (BF): A Structured Approach to Express Bugs. 2016 IEEE International Conference on Software Quality, Reliability, and Security (\rQRS 2016), Vienna, Austria. August 1-3, 2016.\n"},{"id":51,"href":"/BF/Home/Methodology/","title":"Methodology","section":"BF Home","content":"\rBF Methodology\r#\rThe methodology for developing a BF class is as follows (see Fig. 1): First, we identify the software execution phase, where a specific kind of bugs could occur. Then, we identify the operations for that phase. On step 3, we define a BF model showing operations flow. Then, we identify all causes. The initial causes are always improper operations. The intermediate causes are improper operands. On steps 5 and 6, we identify all consequences that propagate as causes to other weaknesses and all the final errors. Then we identify the possible failures. On step 8, we identify the attributes helpful to describe such a bug or weakness. On step 9, we try to identify possible sites in code. This step is applicable mainly for low level bugs.\nFig 1. BF Methodology. - click on image for detailed view.\nWe create bugs models to help us identify the BF classes. They show the phases, where particular types of bugs could occur, and the possible flow of operations. For example, the memory bugs model shows the identifies phases and operations for memory addressing, allocation, use, and deallocation bugs. It assures the corresponding BF classes MAD, MAL, MUS, and MDL do not overlap in operations.\n"},{"id":52,"href":"/BF/BF-Classes/_MEM/MUS/","title":"MUS","section":"Memory Bugs","content":"\rMemory Use Bugs (MUS) CLass\r#\rDefinition\r#\rWe define Memory Use Bugs (MUS) as follows:\nAn object is initialized, read. written, or cleared, improperly. Taxonomy\r#\rFig. 1 depicts MUS causes, attributes and consequences.\nFig 1. Memory Use Bugs (MUS) Class - click on image for detailed view.\nOperations\r#\rThe MUS operations are: Initialize (Object), Dereference, Read, Write, Clear. They reflect improper use of an object.\nOperation Value Definition Initialize (object) The first write into an object, after it is allocated. Read Gets content from an object. Write Puts content into an object. Clear The very last write into an object, before it is deallocated. Dereference Overreaches Initialize, Read, Write, and Clear, focus is on object access, no matter if it’s for reading or for writing. Causes\r#\rThe graph of causes shows that there are three main causes for memory allocation bugs: Improper Operation, Improper Pointer, and Improper Object.\nImproper Operation Value Definition Missing The operation is absent. Mismatched The deallocation function does not match the allocation function used for the same object. Erroneous There is a bug in the implementation of the operation. Improper Pointer Value Definition NULL Pointer Points to the zero address, a specific invalid address. Wild Pointer Points to an arbitrary address, because it has not been initialized or an erroneous allocation routine is used. Dangling Pointer Still points to the address of its successfully deallo- cated object. Over Bounds Points over the bounds of its object. Under Bounds Points under the bounds of its object. Untrusted Pointer The pointer is modified to an improperly checked address. Wrong Position Points to a miscalculated position inside object bounds. Casted Pointer The pointer does not match the type of the object, due to wrong type casting. Forbidden Address The pointer points to an OS protected or non-existing address. Improper Object Value Definition Not Enough Allocated The allocated memory is too little for the data it should store. Consequences\r#\rThe graph of consequences shows Memory Error as a consequence.\nMemory Error Value Definition Uninitialized Object Object data is not filled in before use. Not Cleared Object Object data not overwritten before deallocation. NULL Pointer Dereference Attempt to access an object for read or write through a NULL pointer. Untrusted Pointer Dereference Attempt to access an object via an altered pointer (not legitimate derefer- ence of tainted pointers). Object Corruption Object data is unintentionally altered. Type Confusion Pointer and object have different types. Use After Free Attempt to use a deallocated object. Buffer Overflow Read or write above the object upper bound. Buffer Underflow Read or write below the object lower bounds. Unitialized Pointer Derefereance An attempt to access an object for read or write via an uninitialized pointer. Attributes\r#\rThe attributes of MUS are:\nName Value Definition Mechanism Direct The operation is performed over a particular object element. Sequential The operation is performed after iterating over the object elements. Source Code Codebase The operation is in programmer’s code – in the application itself. Third Party The operation is in a third party library. Standard Library The operation is in the standard library for a particular programming language. Language Processor The operation is in the tool that allows execution or creates executable (compiler, assembler, interpreter). Execution Space Userland The bugged code runs in an environment with privilege levels, but in unprivileged mode (e.g., ring 3 in x86 architecture). Kernel The bugged code runs in an environment with privilege levels with access privileged instruc- tions (e.g., ring 0 in x86 architecture). Bare-Metal The bugged code runs in an environment with-out privilege control. Usually, the program is the only software running and has total access to the hardware. Span Little A few bytes of memory are accessed. Moderate Several bytes of memory are accessed, but less than 1 KB. Huge More than 1 KB of memory is accessed. Location Stack The object is a non-static local variable (defined in a function, a passed parameters, or a function return address). Heap The object is a dynamically allocated data structure (e.g., via malloc() and new). Sites\r#\rMUS sites are any dereference operators in the source code (*, [], -\u0026gt;, .).\nApplication\r#\rApplication examples can be found here: CVE-2014-0160, CVE-2018-20991.\n"},{"id":53,"href":"/BF/BF-Classes/_DAT/TCM/","title":"TCM","section":"Data Type Bugs","content":"\rType Computation Bugs (TCM) Class\r#\rDefinition\r#\rWe define Type Computation Bugs (TCM) as follows:\nAn arithmetic expression (over numbers, strings, or pointers) is calculated improperly, or a boolean condition is evaluated improperly. Taxonomy\r#\rFig. 1 depicts TCM causes, attributes and consequences.\nFig 1. Type Computation Bugs (TCM) Class - click on image for detailed view.\nOperations\r#\rThe TCM operations are: Calculate and Evaluate. They reflect the improper use of data types in arithmetic calculations and condition evaluations.\nOperation Value Definition Calculate Find the result of a numeric, pointer, or string operation. Evaluate Find the result of a boolean condition (incl. comparison). Causes\r#\rThe graph of causes shows that there are three main causes for declaration bugs: Improper Operation, Improper Data Value, Improper DataType, and Improper Function.\nImproper Operation Value Definition Examples Wrong An inappropriate data type is specified; or an inappropriate function/operator is used. An object is declared int, while it should be float. A class implements a cloneable or a serializable interface. Comparison via = vs. ==. Erroneous The Type System or a compute function implementation has a bug. Incorrect data type inference. Wrong order or number of arguments to a function call. Incorrect deep objects comparison implementation. Operands Concept Definition Data Value A numeric, text, pointer/address, or boolean value stored in an object’s memory. Data Type A set of allowed values and the operations allowed over them. Function An organized block of code that when called takes in data, processes it, and produces a result(s). Consequences\r#\rThe graph of consequences shows Improper DataValue and Type Computation Error as consequences.\nImproper Data Value Concept Definition Under Range Data value is smaller than type’s lower range. Over Range Data value is larger than type’s upper range. Flipped Sign Sign bit is overwritten from type related calculation. Wrong Argument Value Inaccurate input data value; i.e., non-verified for harmed semantics. Wrong Object Resolved Value Object is resolved from wrong scope. Reference vs. Object Object’s address instead of object’s data value. Wrong Result Incorrect value from type conversion or computation. Wrap Around A moved around-the-clock value over its data type upper or lower range, as it exceeds that range. (Integer Over-/Under-flow is a wrapped-around the upper/lower range integer value; may become very small/large and change to the opposite sign.) Truncated Value Rightmost bits of value that won’t fit type size are cut off. Distorted Value Incorrect value (although fits type size) due to sign flip or signed/unsigned and vice versa conversions. Rounded Value Real number value precision loss. Type Computation Error Value Definition Undefined The Type System cannon represent the computa- tion result (e.g. division by 0). Attributes\r#\rThe attributes of TCM are:\nName Value Definition Source Code Codebase The operation is in programmer’s code – in the application itself. Third Party The operation is in a third party library. Standard Library The operation is in the standard library for a particular programming language. Compiler/Interpreter The operation is in the language processor that allows execution or creates executables (compiler, assembler, interpreter). Data Type Kind Primitive Mimics the hardware units and is not built from other data types – e.g. int (long, short, signed), float, double, string, boolean. Structured Builds of other data types; have members of primitive and/or structured data types – e.g. array, record, struct, union, class, interface. Mechanism Function An organized block of code that when called takes in data, processes it, and returns a result. Operator A function with a symbolic name that implements a mathematical, relational or logical operation. Method A member function of an OOP class. Lambda Expression An anonymous function, implemented within another function. Procedure A function with a void return type Data Value Kind Numeric A number stored in an object’s memory. Text A string stored in an object’s memory. Pointer A holder of the memory address of an object. Boolean A truth value (true or false; 1 or 0), stored in an object’s memory. Sites\r#\rTCM sites are the arithmetic, bitwise shift, concatenation, pointer arithmetics, pointer scal- ing, relational, and boolean operators.\nApplication\r#\rApplication examples can be found here: CVE-2021-21834, CVE-2021-23440, CWE-468.\n"},{"id":54,"href":"/BF/Home/Impact/","title":"Impact","section":"BF Home","content":"\rBF Impact\r#\rBF will allow precise communication about software bugs and weaknesses and will help identify exploit mitigation techniques.\n➢ Government could improve the descriptions in public vulnerability repositories and create policies and guidelines for software testing.\n➢ Software companies could improve the testing tools and their bug reports and implement automatic bugs finding and fixing.\n➢ Professors could teach better about bugs and weaknesses and conduct research on formalizing software bugs.\nAll this will lead to improved communication about software vulnerabilities, increased precision of code review tools, and decreasing software bugs and weaknesses.\n"},{"id":55,"href":"/BF/BF-Classes/_MEM/MDL/","title":"MDL","section":"Memory Bugs","content":"\rMemory Deallocation Bugs (MDL) Class\r#\rDefinition\r#\rWe define Memory Deallocation Bugs (MDL) as follows:\nAn object is dealocated, reduced, or reallocated (while reducing) improperly. Taxonomy\r#\rFig. 1 depicts MDL causes, attributes and consequences.\nFig 1. Memory Deallocation Bugs (MDL) Class - click on image for detailed view.\nOperations\r#\rThe MDL operations are: Deallocate, Reduce, Reallocate–Reduce. They reflect improper release of an object.\nOperation Value Definition Deallocate Releases the allocated memory of an object. Reduce Deallocates part of the object memory; redefines its bound- aries and size. Reallocate–Reduce Allocates a new smaller space in memory for an object at a new address, copies part of the object content there, reassigns the pointer, and deallocates the previous piece of memory. Causes\r#\rThe graph of causes shows that there are three main causes for Memory Deallocation bugs: Improper Operation, Improper Pointer, and Improper Object.\nImproper Operation Value Definition Missing The operation is absent. Mismatched The deallocation function does not match the allocation function used for the same object. Erroneous There is a bug in the implementation of the operation. Improper Pointer Value Definition Wild Pointer Points to an arbitrary address, because it has not been initialized or an erroneous allocation routine is used. Dangling Pointer Still points to the address of its successfully deallo- cated object. Wrong Position Points to a miscalculated position inside object bounds. Hardcoded Address The pointer points a wrong specific address. Forbidden Address The pointer points to an OS protected or non-existing address. Improper Object Value Definition Wrong Size Used The value used as size does not match the real size of the object. Not Enough Allocated The allocated memory is too little for the data it should store. Consequences\r#\rThe graph of consequences shows Improper Pointer for Next Operation, Improper object for Next Operation, and Memory Error.\nImproper Pointer for Next Operation Value Definition NULL Pointer Points to the zero address, a specific invalid address. Improper Object for Next Operation Value Definition Not Enough Allocated The allocated memory is too little for the data it should store. Memory Error Value Definition Memory Leak An object has no pointer pointing to it. Double Free Attempt to deallocate a deallocated object or via an uninitialized pointer. Object Corruption Object data is unintentionally altered. Attributes\r#\rThe attributes of MDL are:\nName Value Definition Mechanism Implicit The operation is performed without a function call. Explicit The operation is performed by a function/ method) call. Source Code Codebase The operation is in programmer’s code – in the application itself. Third Party The operation is in a third party library. Standard Library The operation is in the standard library for a particular programming language. Language Processor The operation is in the tool that allows execution or creates executable (compiler, assembler, interpreter). Execution Space Userland The bugged code runs in an environment with privilege levels, but in unprivileged mode (e.g., ring 3 in x86 architecture). Kernel The bugged code runs in an environment with privilege levels with access privileged instruc- tions (e.g., ring 0 in x86 architecture). Bare-Metal The bugged code runs in an environment with-out privilege control. Usually, the program is the only software running and has total access to the hardware. Ownership None The object has no owner. Single The object has one owner. Shared The object has more than one owner. Location Stack The object is a non-static local variable (defined in a function, a passed parameters, or a function return address). Heap The object is a dynamically allocated data structure (e.g., via malloc() and new). Sites\r#\rMDL sites are any deallocation routine (e.g., free()) or the del operator, any end of scope for implicit allocated variables, any OOP destructor, or any reduction routine (e.g., realloc()) or removing elements from a container object.\n"},{"id":56,"href":"/BF/Publications/","title":"Publications","section":"Overview","content":"\rPublications\r#\rI. Bojanova and C. E. Galhardo, \u0026ldquo;\rBug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities,\u0026rdquo; in IT Professional, vol. 25, no. 1, pp. xx-xx, PREPRINT, 1 Jan.-Feb. 2023, doi: 10.1109/MITP.2023.0000000. I. Bojanova, C. E. Galhardo and S. Moshtari, \u0026ldquo;Data Type Bugs Taxonomy: Integer Overflow, Juggling, and Pointer Arithmetics in Spotlight,\u0026rdquo; 2022 IEEE 29th Annual Software Technology Conference (STC), 2022, pp. 192-205, doi: 10.1109/STC55697.2022.00035, CWE-BF di-graphs with links: https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=935220 I. Bojanova, C. E. Galhardo and S. Moshtari, \u0026ldquo;Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight,\u0026rdquo; 2021 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW), 2021, pp. 111-120 , doi: 10.1109/ISSREW53611.2021.00052, CWE-BF di-graph with links: https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=933193 A. Gueye, C. E. Galhardo, I. Bojanova and P. Mell, \u0026ldquo;A Decade of Reoccurring Software Weaknesses,\u0026rdquo; in IEEE Security \u0026amp; Privacy, vol. 19, no. 6, pp. 74-82, Nov.-Dec. 2021, doi: 10.1109/MSEC.2021.3082757, https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=932064 I. Bojanova and C. Eduardo Galhardo, \u0026ldquo;Classifying Memory Bugs Using Bugs Framework Approach,\u0026rdquo; 2021 IEEE 45th Annual Computers, Software, and Applications Conference (COMPSAC, 2021, pp. 1157-1164, doi: 10.1109/COMPSAC51774.2021.00159, CWE-BF di-graph with links: https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=930038 C. E. Galhardo, P. Mell, I. Bojanova and A. Gueye, “Measurements of the Most Significant Software Security Weaknesses,” Annual Computer Security Applications Conference (ACSAC), pp. 154–164, Dec. 2020, doi: 10.1145/3427228.3427257, https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=930459 I. Bojanova, Y. Yesha, P. E. Black and Y. Wu, \u0026ldquo;Information Exposure (IEX): A New Class in the Bugs Framework (BF),\u0026rdquo; 2019 IEEE 43rd Annual Computer Software and Applications Conference (COMPSAC), 2019, pp. 559-564, doi: 10.1109/COMPSAC.2019.00086, https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=927491 I. Bojanova, Y. Yesha and P. E. Black, \u0026ldquo;Randomness Classes in Bugs Framework (BF): True-Random Number Bugs (TRN) and Pseudo-Random Number Bugs (PRN),\u0026rdquo; 2018 IEEE 42nd Annual Computer Software and Applications Conference (COMPSAC), 2018, pp. 738-745, doi: 10.1109/COMPSAC.2018.00110, https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=925123 I. Bojanova, P. E. Black and Y. Yesha, \u0026ldquo;Cryptography classes in bugs framework (BF): Encryption bugs (ENC), verification bugs (VRF), and key management bugs (KMN),\u0026rdquo; 2017 IEEE 28th Annual Software Technology Conference (STC), 2017, pp. 1-8, doi:\r10.1109/STC.2017.8234453, https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=923663 P. E. Black and I. Bojanova, \u0026ldquo;Defeating Buffer Overflow: A Trivial but Dangerous Bug,\u0026rdquo; in IT Professional, vol. 18, no. 6, pp. 58-61, Nov.-Dec. 2016, doi: 0.1109/MITP.2016.1171, https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=921507 I. Bojanova, P. E. Black, Y. Yesha and Y. Wu, \u0026ldquo;The Bugs Framework (BF): A Structured Approach to Express Bugs,\u0026rdquo; 2016 IEEE International Conference on Software Quality, Reliability and Security (QRS), 2016, pp. 175-182, doi: 10.1109/QRS.2016.29, https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=920564 Wu, Y., Bojanova, I., Yesha, Y. , \u0026ldquo;They Know Your Weaknesses - Do You?: Reintroducing Common Weakness Enumeration. Supply Chain Assurance,\u0026rdquo; September/October 2015, CrossTalk (The Journal of Defense Software Engineering), https://web.archive.org/web/20180425211828id_/http://static1.1.sqspcdn.com/static/f/702523/26523304/1441780301827/201509-Wu.pdf?token=WJEmDLgmpr3rIZHriubA20L%2F1%2F4%3D "},{"id":57,"href":"/BF/BF-Classes/_DAT/TCV/","title":"TCV","section":"Data Type Bugs","content":"\rType Conversion Bugs (TCV) Class\r#\rDefinition\r#\rWe define Type Conversion Bugs (TCV) as follows:\nA data value is cast or coerced into another data type improperly. Taxonomy\r#\rFig. 1 depicts TCV causes, attributes and consequences.\nFig 1. Type Conversion Bugs (TCV) Class - click on image for detailed view.\nOperations\r#\rThe TCV operations are: Cast and Coerce. They reflect the improper use of data types in object data value conversion to another data type.\nOperation Value Definition Cast Explicitly convert the value of an object to another data type. Coerce Implicitly (forced by the Type System) convert the value of a passed in/out argument or the return into the corresponding parameter or return data type. (Type Coercion is known also as Type Juggling.) Causes\r#\rThe graph of causes shows that there are three main causes for declaration bugs: Improper Operation, Improper Data Value, Improper DataType, and Improper Function.\nImproper Operation Value Definition Examples Missing The operation is absent. Missing: constructor +(int,double) overload function override in subtype. Wrong An inappropriate data type is specified; or an inappropriate function/operator is used. An object is declared int, while it should be float. A class implements a cloneable or a serializable interface. Comparison via = vs. ==. Operands Concept Definition Data Value A numeric, text, pointer/address, or boolean value stored in an object’s memory. Data Type A set of allowed values and the operations allowed over them. Function An organized block of code that when called takes in data, processes it, and produces a result(s). Consequences\r#\rThe graph of consequences shows Improper DataValue and Improper Data Type as consequences.\nImproper Data Value Concept Definition Under Range Data value is smaller than type’s lower range. Over Range Data value is larger than type’s upper range. Flipped Sign Sign bit is overwritten from type related calculation. Wrong Argument Value Inaccurate input data value; i.e., non-verified for harmed semantics. Wrong Object Resolved Value Object is resolved from wrong scope. Reference vs. Object Object’s address instead of object’s data value. Wrong Result Incorrect value from type conversion or computation. Wrap Around A moved around-the-clock value over its data type upper or lower range, as it exceeds that range. (Integer Over-/Under-flow is a wrapped-around the upper/lower range integer value; may become very small/large and change to the opposite sign.) Truncated Value Rightmost bits of value that won’t fit type size are cut off. Distorted Value Incorrect value (although fits type size) due to sign flip or signed/unsigned and vice versa conversions. Rounded Value Real number value precision loss. Improper Data Type Concept Definition Wrong Type Data type range or structure is not correct. Wrong Type Resolved Data type is resolved from wrong scope. Wrong Object Resolved Type Object is resolved from wrong scope,so it’s data type might be wrong. Wrong Sign Type Unsigned instead of signed data type is specified or vise versa. Wrong Precision Type Higher precision data type is needed (e.g. double instead of float). Incomplete Type Specific constructor, method, or overloaded function is missing. Mismatched Argument Type Argument’s data type is different from function’s parameter data type. Wrong Generic Type Generic object instantiated via wrong type argument. Confused Subtype Object invoking an overriden function is of wrong subtype data type. Wrong Argument Type Argument to an overloaded function is of wrong data type. Attributes\r#\rThe attributes of TCV are:\nName Value Definition Source Code Codebase The operation is in programmer’s code – in the application itself. Third Party The operation is in a third party library. Standard Library The operation is in the standard library for a particular programming language. Compiler/Interpreter The operation is in the language processor that allows execution or creates executables (compiler, assembler, interpreter). Data Type Kind Primitive Mimics the hardware units and is not built from other data types – e.g. int (long, short, signed), float, double, string, boolean. Structured Builds of other data types; have members of primitive and/or structured data types – e.g. array, record, struct, union, class, interface. Mechanism Pass In Supply ”in” arguments’ data values to a func- tion/ operator. Pass Out Supply ”out” or ”in/out” arguments’ data values or a return value to a function/ operator. Data Value Kind Numeric A number stored in an object’s memory. Text A string stored in an object’s memory. Pointer A holder of the memory address of an object. Boolean A truth value (true or false; 1 or 0), stored in an object’s memory. Sites\r#\rTCV sites are the cast operators and the in/out argument passing and return statements\nApplication\r#\rApplication examples can be found here: CVE-2021-21834, CVE-2021-23440, CWE-468.\n"},{"id":58,"href":"/BF/Team/","title":"Team","section":"Overview","content":"\rBF Team\r#\rIrena Bojanova is the Primary Investigator and the lead of the NIST Bugs Framework (BF). She earned her Ph.D. in Mathematics/Computer Science from the Bulgarian Academy of Sciences. Her current research interests include cybersecurity and formal methods. Dr. Bojanova is the Editor of the Cybersecurity department of the IEEE IT Professional magazine and Associate Editor of the IEEE Computer magazine. She is a Senior member of the IEEE Computer Society. Contact her at irena.bojanova@nist.gov. Carlos E. C. Galhardo is is a researcher at Inmetro, Brazil. He earned his Ph.D. in Physics from the Universidade Federal Fluminense. His research interests include information science, cybersecurity, and mathematical modeling in interdisciplinary applications. Farhan Nadeem is a computer scientist at NIST. He earned his BS in Computer Engineering from the University of Maryland. Currenlty he is majoring in Computer Science from Georgia Intitute of Technology. Collaborators Mehdi Mirakhorli is an associate professor and Kodak Endowed Scholar at Rochester Institute of Technology (RIT). He is the founding director of Software Design and Productivity Laboratory and an affiliated member of the Global Cybersecurity Institute at RIT. His research interests are on the intersection of Software Engineering and Cybersecurity. Dr. Mirakhorli serves on the Editorial Board of the Journal of Software and Systems (JSS) and IEEE Transaction in Software Engineering (TSE). Markus Schordan is a Software Engeneer at Google. Throughout his career, he has been working on aspects of software verification, compiler construction, high-performance computing, and reversible computation. Dr. Schordan is the Editor of the Software Technology column of the IEEE IT Professional magazine. Sara Moshtari is a Ph.D. student at Rochester Institute of Technology (RIT). She received her M.S. in Software Engineering from Shiraz University in 2013. Her research interests include software security, data-driven software analysis, software vulnerability detection, and machine learning. She is also a software developer and works with different programming languages. "},{"id":59,"href":"/BF/Contact/","title":"Contact Us","section":"Overview","content":"\rContact Us\r#\rIrena Bojanova\nEmail: irena.bojanova@nist.gov\nPhone: 301-975-2794\nSoftware Systems Division (SSD)\nInformation Technology Laboratory (ITL)\nNational Institute of Standards and Technology (NIST)\n100 Bureau Dr, Stop 8930\nChemistry 222, Room A307\nGaithersburg, MD 20899\n"},{"id":60,"href":"/BF/Home/hidden/","title":"Hidden","section":"BF Home","content":"\rThis page is hidden in menu\r#\rQuondam non pater est dignior ille Eurotas\r#\rLatent te facies\r#\rLorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona\r#\rO fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); } Fronde cetera dextrae sequens pennis voce muneris\r#\rActa cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "},{"id":61,"href":"/BF/Background/CAPEC/","title":"CAPEC","section":"Background","content":"\rCommon Attack Pattern Enumeration and Classification (CAPEC)\r#\rThe Common Attack Pattern Enumeration and Classification (CAPEC) \u0026ldquo;is a comprehensive dictionary and classification taxonomy of known attacks that can be used by analysts, developers, testers, and educators to advance community understanding and enhance defenses\u0026rdquo; [1].\nExamples\r#\rCAPEC-66: SQL Injection\r#\r\u0026ldquo;This attack exploits target software that constructs SQL statements based on user input. An attacker crafts input strings so that when the target software constructs SQL statements based on the input, the resulting SQL statement performs actions other than those the application intended\u0026hellip;\u0026rdquo; [2]\nCAPEC-540: Overread Buffers\r#\r\u0026ldquo;An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.\u0026rdquo; [3]\nReferences\r#\r[1] The MITRE Corporation. Common Attack Pattern Enumeration and Classification (CAPEC).\n[2] The MITRE Corporation. CAPEC Common Attack Pattern Enumeration and Classification. CAPEC-66: SQL Injection.\n[3] The MITRE Corporation. CAPEC Common Attack Pattern Enumeration and Classification. CAPEC-540: Overread Buffers.\n"},{"id":62,"href":"/BF/Background/CAS/","title":"CAS","section":"Background","content":"\rNSA Center for Assured Software (CAS)\r#\rThe NSA Center for Assured Software (CAS) defines the following Weakness Classes in its \u0026ldquo;Static Analysis Tool Study - Methodology\u0026rdquo; [1]:\nWeakness Class Example Weakness (CWE Entry [2]) Authentication and Access Control CWE-620: Unverified Password Change Buffer Handling CWE-121: Stack-based Buffer Overflow Code Quality CWE-561: Dead Code Control Flow Management CWE-362: Race Condition Encryption and Randomness CWE-328: Reversible One-Way Hash Error Handling CWE-252: Unchecked Return Value File Handling CWE-23: Relative Path Traversal Information Leaks CWE-534: Information Leak Through Debug Log Files Initialization and Shutdown CWE-415: Double Free Injection CWE-89: SQL Injection Malicious Logic CWE-506: Embedded Malicious Code Miscellaneous CWE-480: Use of Incorrect Operator Number Handling CWE-369: Divide by Zero Pointer and Reference Handling CWE-476: Null Pointer Dereference References\r#\r[1] Center for Assured Software (CAS), National Security Agency (NSA). CAS Static Analysis Tool Study - Methodology. 2011.\n[2] The MITRE Corporation. Common Weakness Enumeration (CWE).\n"},{"id":63,"href":"/BF/Background/CERT-C/","title":"CERT C","section":"Background","content":"\rCERT C Coding Standard\r#\rThe SEI CERT C Coding Standard defines the following \u0026ldquo;rules for secure coding in the C programming language\u0026rdquo; with the goal to \u0026ldquo;to develop safe, reliable, and secure systems, for example by eliminating undefined behaviors that can lead to undefined program behaviors and exploitable vulnerabilities\u0026rdquo; [1].\nPreprocessor (PRE)\nPRE30-C. Do not create a universal character name through concatenation\nPRE31-C. Avoid side effects in arguments to unsafe macros\nPRE32-C. Do not use preprocessor directives in invocations of function-like macros\nDeclarations and Initialization (DCL)\nDCL30-C. Declare objects with appropriate storage durations\nDCL31-C. Declare identifiers before using them\nDCL36-C. Do not declare an identifier with conflicting linkage classifications\nDCL37-C. Do not declare or define a reserved identifier\nDCL38-C. Use the correct syntax when declaring a flexible array member\nDCL39-C. Avoid information leakage when passing a structure across a trust boundary\nDCL40-C. Do not create incompatible declarations of the same function or object\nDCL41-C. Do not declare variables inside a switch statement before the first case label\nExpressions (EXP)\nEXP30-C. Do not depend on the order of evaluation for side effects\nEXP32-C. Do not access a volatile object through a nonvolatile reference\nEXP33-C. Do not read uninitialized memory\nEXP34-C. Do not dereference null pointers\nEXP35-C. Do not modify objects with temporary lifetime\nEXP36-C. Do not cast pointers into more strictly aligned pointer types\nEXP37-C. Call functions with the correct number and type of arguments\nEXP39-C. Do not access a variable through a pointer of an incompatible type\nEXP40-C. Do not modify constant objects\nEXP42-C. Do not compare padding data\nEXP43-C. Avoid undefined behavior when using restrict-qualified pointers\nEXP44-C. Do not rely on side effects in operands to sizeof, _Alignof, or _Generic\nEXP45-C. Do not perform assignments in selection statements\nEXP46-C. Do not use a bitwise operator with a Boolean-like operand\nIntegers (INT)\nINT30-C. Ensure that unsigned integer operations do not wrap\nINT31-C. Ensure that integer conversions do not result in lost or misinterpreted data\nINT32-C. Ensure that operations on signed integers do not result in overflow\nINT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors\nINT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand\nINT35-C. Use correct integer precisions\nINT36-C. Converting a pointer to integer or integer to pointer\nFloating Point (FLP)\nFLP30-C. Do not use floating-point variables as loop counters\nFLP32-C. Prevent or detect domain and range errors in math functions\nFLP34-C. Ensure that floating-point conversions are within range of the new type\nFLP36-C. Preserve precision when converting integral values to floating-point type\nFLP37-C. Do not use object representations to compare floating-point values\nArray (ARR)\nARR30-C. Do not form or use out-of-bounds pointers or array subscripts\nARR32-C. Ensure size arguments for variable length arrays are in a valid range\nARR36-C. Do not subtract or compare two pointers that do not refer to the same array\nARR37-C. Do not add or subtract an integer to a pointer to a non-array object\nARR38-C. Guarantee that library functions do not form invalid pointers\nARR39-C. Do not add or subtract a scaled integer to a pointer\nCharacters and Strings (STR)\nSTR30-C. Do not attempt to modify string literals STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator\nSTR32-C. Do not pass a non-null-terminated character sequence to a library function that expects a string\nSTR34-C. Cast characters to unsigned char before converting to larger integer sizes\nSTR37-C. Arguments to character-handling functions must be representable as an unsigned char\nSTR38-C. Do not confuse narrow and wide character strings and functions\nMemory Management (MEM)\nMEM30-C. Do not access freed memory MEM31-C. Free dynamically allocated memory when no longer needed\nMEM33-C. Allocate and copy structures containing a flexible array member dynamically\nMEM34-C. Only free memory allocated dynamically\nMEM35-C. Allocate sufficient memory for an object\nMEM36-C. Do not modify the alignment of objects by calling realloc()\nInput/Output (FIO)\nFIO30-C. Exclude user input from format strings\nFIO32-C. Do not perform operations on devices that are only appropriate for files\nFIO34-C. Distinguish between characters read from a file and EOF or WEOF\nFIO37-C. Do not assume that fgets() or fgetws() returns a nonempty string when successful\nFIO38-C. Do not copy a FILE object\nFIO39-C. Do not alternately input and output from a stream without an intervening flush or positioning call\nFIO40-C. Reset strings on fgets() or fgetws() failure\nFIO41-C. Do not call getc(), putc(), getwc(), or putwc() with a stream argument that has side effects\nFIO42-C. Close files when they are no longer needed\nFIO44-C. Only use values for fsetpos() that are returned from fgetpos()\nFIO45-C. Avoid TOCTOU race conditions while accessing files\nFIO46-C. Do not access a closed file\nFIO47-C. Use valid format strings\nEnvironment (ENV)\nENV30-C. Do not modify the object referenced by the return value of certain functions\nENV31-C. Do not rely on an environment pointer following an operation that may invalidate it\nENV32-C. All exit handlers must return normally\nENV33-C. Do not call system()\nENV34-C. Do not store pointers returned by certain functions\nSignals (SIG)\nSIG30-C. Call only asynchronous-safe functions within signal handlers\nSIG31-C. Do not access shared objects in signal handlers\nSIG34-C. Do not call signal() from within interruptible signal handlers\nSIG35-C. Do not return from a computational exception signal handler\nError Handling (ERR)\nERR30-C. Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure\nERR32-C. Do not rely on indeterminate values of errno\nERR33-C. Detect and handle standard library errors\nConcurrency (CON)\nCON30-C. Clean up thread-specific storage\nCON31-C. Do not destroy a mutex while it is locked\nCON32-C. Prevent data races when accessing bit-fields from multiple threads\nCON33-C. Avoid race conditions when using library functions\nCON34-C. Declare objects shared between threads with appropriate storage durations\nCON35-C. Avoid deadlock by locking in a predefined order\nCON36-C. Wrap functions that can spuriously wake up in a loop\nCON37-C. Do not call signal() in a multithreaded program\nCON38-C. Preserve thread safety and liveness when using condition variables\nCON39-C. Do not join or detach a thread that was previously joined or detached\nCON40-C. Do not refer to an atomic variable twice in an expression\nCON41-C. Wrap functions that can fail spuriously in a loop\nMiscellaneous (MSC)\nMSC30-C. Do not use the rand() function for generating pseudorandom numbers\nMSC32-C. Properly seed pseudorandom number generators\nMSC33-C. Do not pass invalid data to the asctime() function\nMSC37-C. Ensure that control never reaches the end of a non-void function\nMSC38-C. Do not treat a predefined identifier as an object if it might only be implemented as a macro\nMSC39-C. Do not call va_arg() on a va_ list that has an indeterminate value\nMSC40-C. Do not violate constraints\nReferences\r#\r[1] SEI CERT. C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems. 2016.\n"},{"id":64,"href":"/BF/Background/CVE/","title":"CVE","section":"Background","content":"\rCommon Vulnerabilities and Exposures (CVE)\r#\rThe Common Vulnerabilities and Exposures (CVE) is \u0026ldquo;a dictionary of publicly known information security vulnerabilities and exposures\u0026rdquo; [1]. \u0026ldquo;CVE\u0026rsquo;s common identifiers enable data exchange between security products and provide a baseline index point for evaluating coverage of tools and services.\u0026rdquo; [1]\nExamples\r#\rCVE-2014-0160 (Heartbleed)\r#\r\u0026ldquo;The (1) TLS and (2) DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to d1_both.c and t1_lib.c, aka the Heartbleed bug.\u0026rdquo; [2]\nCVE 2007-3572 (Yoggie Pico)\r#\r\u0026ldquo;Incomplete blacklist vulnerability in cgi-bin/runDiagnostics.cgi in the web interface on the Yoggie Pico and Pico Pro allows remote attackers to execute arbitrary commands via shell metacharacters in the param parameter, as demonstrated by URL encoded \u0026ldquo;`\u0026rdquo; (backtick) characters (%60 sequences).\u0026rdquo; [3]\nReferences\r#\r[1] The MITRE Corporation. Common Vulnerabilities and Exposures or (CVE).\n[2] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2014-0160.\n[3] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2007-3572.\n"},{"id":65,"href":"/BF/Background/CWE/","title":"CWE","section":"Background","content":"\rCommon Weakness Enumeration (CWE)\r#\rThe Common Weakness Enumeration (CWE) is an \u0026ldquo;encyclopedia\u0026rdquo; of over 600 types of software weaknesses [1]. Some of the classes are buffer overflow, directory traversal, OS injection, race condition, cross-site scripting, hard-coded password and insecure random numbers. CWE is a widely-used compilation, which has gone through many iterations. Many tools and projects are based on it. Each CWE has a variety of information, such as description summary, extended description, white box definition, consequences, examples, background details and other notes, recorded occurrences (Common Vulnerabilities and Exposures or CVE), mitigations, relations to other CWEs, and references.\nExamples\r#\rCWE-89: Improper Neutralization of Special Elements used in an SQL Command (\u0026lsquo;SQL Injection\u0026rsquo;)\r#\r\u0026ldquo;The software constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.\u0026rdquo; [2]\nCWE-226: Sensitive Information Uncleared Before Release\r#\r\u0026ldquo;The software does not fully clear previously used information in a data structure, file, or other resource, before making that resource available to a party in another control sphere.\u0026rdquo; [3]\nNotes\r#\rCWEs are a rich source of material for software developers and superior to anything that existed before. However, for very formal, exacting work, CWE definitions are often inaccurate, imprecise or ambiguous, and the various definitions within one CWE can be inconsistent. Each CWE bundles many stages, such as likely attacks, resources affected and consequences. The coverage is uneven, with some combinations of attributes well represented and others not appearing at all.\nAn extreme example is path traversal. There are a dozen CWEs for path traversal under CWE-23: Relative Path Traversal, each one having a specific combination of relative or absolute paths, forward or backward slashes - singly or repeated, between one and three directory steps, and two or more dots, which indicate the parent directory.\nAnother example is buffer overflows. CWE-121 is write outside of a buffer on the stack, CWE-122 is write outside of a buffer in the heap, CWE-127 is read before the beginning of a buffer and CWE-126 is read after the end of a buffer. But there are no CWEs specifically for read outside a buffer on the stack vs. in the heap.\nThe description summary of CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer is \u0026ldquo;The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer.\u0026rdquo; Note that \u0026ldquo;read from or write to a memory location\u0026rdquo; is not explicitly tied to the buffer! Most humans would, of course, assume that it means the software can access through a buffer a memory location that is not allocated to that buffer.\nReferences\r#\r[1] The MITRE Corporation. Common Weakness Enumeration (CWE).\n[2] The MITRE Corporation. CWE Common Weakness Enumeration. CWE-89: Improper Neutralization of Special Elements used in an SQL Command (\u0026lsquo;SQL Injection\u0026rsquo;).\n[3] The MITRE Corporation. CWE Common Weakness Enumeration. CWE-226: Sensitive Information Uncleared Before Release.\n"},{"id":66,"href":"/BF/Background/ISOIECJTCTR/","title":"ISOIECJTCTR","section":"Background","content":"\rISO/IEC JTC1/SC22/WG23 Technical Report \u0026ldquo;Guidance to Avoiding Vulnerabilities in Programming Languages\r#\rISO/IEC/JTC 1/SC 22/WG 23 is working on a Technical Report (RT), which includes a \u0026ldquo;taxonomic hierarchy of vulnerabilities\u0026rdquo;, giving each vulnerability an arbitrary three-letter code [1]. The general part, TR 24772-1, is an and applies to all languages. There are many supplements, one for each language \u0026ndash; for example, TR24772-2 Ada, TR24772-3 C, and TR24772-9 C++.\nThe heart of the TR is specific suggestions to avoid vulnerabilities that arise from \u0026ldquo;constructs that incompletely specified, exhibit undefined behavior, are implementation-dependent, or are difficult to use correctly.\u0026rdquo; The classes of vulnerabilities can also be used to \u0026ldquo;select source code evaluation tools that can discover and eliminate some constructs that could lead to vulnerabilities\u0026rdquo;. Some suggestions are, \u0026ldquo;Assume all input is malicious\u0026rdquo;, \u0026ldquo;Use appropriate combinations of black-lists and white-lists \u0026hellip;\u0026rdquo;, \u0026ldquo;Use sanitizers to scrub input \u0026hellip;\u0026rdquo;, \u0026ldquo;Compare multiple attributes of the file to improve the likelihood that the file is the expected one\u0026rdquo;, and \u0026ldquo;Restrict the use of shared directories\u0026rdquo;.\nA.2 Outline of Programming Language Vulnerabilities\r#\rA.2.1. Types\nA.2.1.1. Representation\nA.2.1.1.1. [IHN] Type System\nA.2.1.1.2. [STR] Bit Representations\nA.2.1.2. Floating-point\nA.2.1.2.1. [PLF] Floating-point Arithmetic\nA.2.1.3. Enumerated Types\nA.2.1.3.1. [CCB] Enumerator Issues\nA.2.1.4. Integers\nA.2.1.4.1. [FLC] Numeric Conversion Errors\nA.2.3. Declarations and Definitions\nA.2.3.1. [NAI] Choice of Clear Names\nA.2.3.2. [WXQ] Dead store\nA.2.3.3. [YZS] Unused Variable\nA.2.5. Control Flow\nA.2.5.1. Conditional Statements\nA.2.5.1.1. [CLL] Switch Statements and Static Analysis\nA.2.5.1.2. [EOJ] Demarcation of Control Flow\nA.2.5.2. Loops\nA.2.5.2.1. [TEX] Loop Control Variables\nA.2.5.2.2. [XZH] Off-by-one Error\nA.2.9. Macros\nA.2.9.1. [NMP] Pre-processor Directives\nA.2.10. Compile/Run Time\nA.2.10.1 [MXB] Suppression of Language-Defined Run-Time Checking\nA.2.10.2 [SKL] Provision of Inherently Unsafe Operations\nA.2.11. Language Specification Issues\nA.2.11.1. [BRS] Obscure Language Features\nA.2.11.2. [BQF] Unspecified Behaviour\nA.3 Outline of Application Vulnerabilities\nA.3.1. Design Issues\nA.3.1.1. [BVQ] Unspecified Functionality\nA.3.1.2 [REU] Fault Tolerance and Failure Strategies\nA.3.1.3. [KLK] Distinguished Values in Data Types\nA.3.2. Environment\nA.3.2.1. [XYN] Adherence to Least Privilege\nA.3.2.2. [XYO] Privilege Sandbox Issues\nA.3.2.3. [XYS] Executing or Loading Untrusted Code\nA.3.3. Resource Management\nA.3.3.1. Memory Management\nA.3.3.1.1. [XZX] Memory Locking\nA.3.4 Concurrency and Parallelism\nA.3.4.1 [CGY] Inadequately Secure Communication of Shared Resources\nA.3.5. Flaws in Security Functions\nA.3.5.1. [XZS] Missing Required Cryptographic Step\nA.3.5.2. [MVX] Use of a One-Way Hash without a Salt\nA.3.5.2. Authentication\nA.3.5.2.1. [XZR] Improperly Verified Signature\nA.3.5.2.2. [XYM] Insufficiently Protected Credentials\nReferences\r#\r[1] ISO/IEC/JTC 1/SC 22/WG 23 DOCUMENT REGISTER.\n"},{"id":67,"href":"/BF/Background/OWASP/","title":"OWASP","section":"Background","content":"\rOpen Web Application Security Project (OWASP)\r#\rThe Open Web Application Security Project (OWASP) defines the following categories of vulnerabilities [1].\nAPI Abuse Authentication Vulnerability Authorization Vulnerability Availability Vulnerability Code Permission Vulnerability Code Quality Vulnerability Configuration Vulnerability Cryptographic Vulnerability Encoding Vulnerability Environmental Vulnerability Error Handling Vulnerability General Logic Error Vulnerability Input Validation Vulnerability Logging and Auditing Vulnerability Password Management Vulnerability Path Vulnerability Sensitive Data Protection Vulnerability Session Management Vulnerability Unsafe Mobile Code Use of Dangerous API References\n[1] Open Web Application Security Project (OWASP), 2016.\n"},{"id":68,"href":"/BF/Background/SFP/","title":"SFP","section":"Background","content":"\rSoftware Fault Patterns (SFP)\r#\rThe Software Fault Patterns (SFP) [1] are a clustering of CWEs into related weakness categories. Each cluster is factored into formally defined attributes, with sites (\u0026ldquo;footholds\u0026rdquo;), conditions, properties, sources, sinks, etc. This work overcomes the problem of combinations of attributes in CWE. For instance, the SFP factored attributes are more clear than the irregular coverage of CWEs.\n\u0026ldquo;Software Fault Patterns (SFP) is a generalized description of an identifiable family of computations that are:\nDescribed as patterns with an invariant core and variant parts. Aligned with injury. Aligned with operational views and risk through events. Fully identifiable in code (discernable). Aligned with CWE. With formally defined characteristics.\u0026rdquo; [2] SFP categorizes 632 CWEs plus there are 8 deprecated CWEs, so the CWEs defined as weaknesses total 640. In addition, there are: 21 primary clusters, 62 secondary clusters, 310 discernible CWEs, 36 unique SFPs. [3]\nClusters and SFPs\r#\rPrimary Clusters Secondary Cluster SFP 1. Risky Values 1. Glitch in Computation SFP1 2. Unused Entities 1. Unused Entities SFP2 3. API 1. Use of an Improper API SFP3 4. Exception Management 1. Unchecked Status Condition 2. Ambiguous Exception Type 3. Incorrect exception Behavior SFP4 SFP5 SFP6 5. Memory Access 1. Faulty Pointer Use 2. Faulty Buffer Access 3. Faulty String Expansion 4. Incorrect Buffer Length Computation 5. Improper NULL Termination SFP7 SFP8 SFP9 SFP10 SFP11 6. Memory Management 1. Faulty Memory Release SFP12 7. Resource Management 1. Unrestricted Consumption 2. Failure to release resource 3. Faulty Resource Use 4. Life Cycle SFP13 SFP14 SFP15 8. Path Resolution 1. Path Traversal 2. Failed Chroot Jail 3. Link in Resource Name Resolution SFP16 SFP17 SFP18 9. Synchronization 1. Missing Lock 2. Race Condition Window 3. Multiple Locks/Unlocks 4. Unrestricted Lock SFP19 SFP20 SFP21 SFP22 10. Information Leak 1. Exposed Data 2. State Disclosure 3. Exposure Through Temporary files 4. Other Exposures 5. Insecure Session Management SFP23 11. Tainted Input 1. Tainted Input to Command 2. Tainted Input to Variable 3. Composite Tainted Input 4. Faulty input Transformation 5. Incorrect Input Handling 6. Tainted Input to Environment SFP24 SFP25 SFP26 SFP27 12. Entry Points 1. Unexpected Access Points SFP28 13. Authentication 1. Authentication Bypass 2. Faulty Endpoint Authentication 3. Missing Endpoint Authentication 4. Digital Certificate 5. Missing Authentication 6. Insecure Authentication Policy 7. Multiple binds to the Same Port 8. Hardcoded Sensitive Data 9. Unrestricted Authentication SFP29 SFP30 SFP31 SFP32 SFP33 SFP34 14. Access Control 1. Insecure Resource Access 2. Insecure Resource Permissions 3. Access Management SFP35 15. Privilege 1. Privilege SFP36 16. Channel 1. Channel Attack 2. Protocol Error 17. Cryptography 1. Broken Cryptography 2. Weak Cryptography 18. Malware 1. Malicious Code 2. Covert Channel 19. Predictability 1. Predictability 20. UI 1. Feature 2. Information Loss 3. Security 21. Other 1. Architecture 2. Design 3. Implementation 4. Compiler Example\r#\rSFP 8 Faulty Buffer Access\r#\r\u0026ldquo;Primary Cluster: Memory Access; Secondary Cluster: Faulty Buffer Access\nA weakness where the code path has all of the following:\nan end statement that performs a Buffer Access Operation and where exactly one of the following is true:\nthe access position of the Buffer Access Operation is outside of the buffer or* the access position of the Buffer access Operation is inside the buffer and the size of the data being accessed is greater than the remaining size of the buffer at the access position.\nThis is where the Buffer Access Operation is a statement that performs access to a data item of a certain size at access position. The access position of a Buffer access Operation is related to a certain buffer and can be either inside the buffer or outside of the buffer.\nParameters:\nAccess: Reads, Writes Buffer: Stack, Heap Access Position: Array with index, Pointer.\u0026rdquo; [3] Notes\r#\rSFP is an excellent advance. However, SFP does not tie fault clusters to causes or chains of fault patterns nor to consequences of a particular vulnerability. In addition, since they were derived from CWEs, more work is needed for embedded or mobile concerns, such as, battery drain, physical sensors (e.g. Global Positioning System (GPS) location, gyroscope, microphone, camera) and wireless communications.\nReferences\r#\r[1] N. Mansourov and D. Campara, \u0026ldquo;\rSystem Assurance: Beyond Detecting Vulnerabilities.\u0026rdquo; Morgan Kaufmann. 2010. pp. 176-188.\n[2] N. Mansourov. DoD Software Fault Patterns. KDM Analytics, Inc. 2011.\n[3] B. A. Calloni, D. Campara, and N. Mansourov. White Box Definitions of Software Fault Patterns. Final Report. Lockheed Martin Corporation and KDM Analytics, Inc. 2011.\n"},{"id":69,"href":"/BF/Background/SOAR/","title":"SOAR","section":"Background","content":"\rSoftware State-of-the-Art Resources (SOAR) Matrix\r#\rThe Software State-of-the-Art Resources (SOAR) Matrix defines and describes a process for selecting and using appropriate analysis tools and techniques for evaluating software for software (security) assurance. In particular, it identifies types of tools and techniques available for evaluating software, as well as the following technical objectives those tools and techniques can meet. [1]\nTechnical objective\nhigh-level\nlower-level\nlower-lower-level\nfourth level, based on specific weaknesses)\n1. Provide design \u0026amp; code quality\nGeneral: Failure to adhere\nUse of Obsolete Functions\nUse of Potentially Dangerous Function\n2. Counter known vulnerabilities (CVEs)\n3. Ensure authentication and\naccess control\nAuthentication Issues\nMissing Authentication for Critical Function\nImproper Restriction of Excessive Authentication Attempts\nOther authentication issues\nCredentials Management\nUse of Hard-coded Credentials (Not put in maliciously)\nOther credential issues\nPermissions, Privileges, and Access Control\nMissing Authorization {Also - design issue}\nImproper/Incorrect Authorization\nPermission issues, including incorrect default permissions and incorrect Permission Assignment for Critical Resource\nReliance on Untrusted Inputs in a Security Decision\nOther failure to enforce\nLeast Privilege\nExecution with Unnecessary Privileges\nLeast Privilege violation [in implementation, including grandfathering]\nOther privilege/sandbox issues\n4. Counter unintentional-\"like\" weaknesses\nBuffer Handling\nBuffer Errors\nIncorrect Calculation of Buffer Size\nClassic Buffer Overflow\nOther\nInjection\nCross-Site Request Forgery (CSRF)\nCross-Site Scripting (XSS)\nCode Injection\nUnrestricted Upload of File with Dangerous Type\nDownload of Code Without Integrity Check\nOther code injection\nFormat String Vulnerability\nOS Command Injections\nSQL Injection\nInput Validation\nURL Redirection to Untrusted Site (\"Open Redirect\") [child of CWE-20]\nOther input validation\nEncryption and Randomness\nCryptographic Issues\nMissing Encryption of Sensitive Data\nUse of a Broken or Risky Cryptographic Algorithm\nUse of Password Hash With Insufficient Computational Effort (incl. Use of a One-Way Hash without a Salt)\nImproper Certificate Validation\nOther cryptographic issues\nRandomness issues\nFile Handling\nPathname Traversal and Equivalence Errors (including Link Following; note that NVD uses \u0026quot;link following\u0026quot;)\nPath Traversal\nOther\nInformation Leaks\nInformation Leak / Disclosure\nNumber Handling\nNumeric Errors\nInteger Overflow or Wraparound\nOther\nControl flow management\nRace Conditions\nExcessive Iteration\nInitialization and Shutdown [of resources/components]\nResource Management Errors\nDesign Error\nDesign Error\nInclusion of Functionality from Untrusted Control Sphere\nOther design errors\nSystem Element Isolation\nError Handling \u0026amp; Fault isolation\nPointer and reference handling\n5. Counter intentional-\u0026quot;like\u0026quot;/ malicious logic\nKnown malware\nKnown viruses without polymorphic/metamorphic code\nKnown viruses with polymorphic/metamorphic code\nKnown Worms\nKnown Trojan horses (rootkits, key loggers, etc.)\nOther\nNot known malware\nTime bombs\nLogic bombs (condition other than time triggers failure)\nBack doors/ trap doors (ways to get in, e.g., ports, fixed *undoc* passwords, etc.)\nEmbedded malicious logic, e.g., Trojan horse (additional functionality not desired by user)\nSpyware\nUnrevealed \u0026quot;Phone home\u0026quot; control (Note: Updates can be used this way, but are not necessarily malicious)\nApplication collusion (other than covert channels)\nCovert channel\nPlanned/built-in obsolesence not revealed to user/acquirer\n6. Provide anti-tamper and ensure transparency\nAnti-tamper\nImpede technology transfer (obfuscation)\nImpede alteration of system capability\nImpede countermeasure development\nEnsure transparency (detect obfuscation)\n7. Counter development tool inserted weaknesses\nUnintentional vulnerability insertion\nMalicious code insertion\n8. Provide secure delivery\nDownload of Code Without Integrity Check [at delivery/installation time, vs. execution time]\n9. Provide secure configuration\n10. Other\nExcessive power consumption\nReferences\r#\r[1] Larsen, G., Kenneth Hong Fong, E., Wheeler, D. A., Moorthy. R. S. State-of-the-Art Resources (SOAR) for Software Vulnerability Detection, Test, and Evaluation. 2014.\n[2] Institute for Defense Analyses (IDA). Software State-of-the-Art Resources (SOAR) Matrix.\n"}]