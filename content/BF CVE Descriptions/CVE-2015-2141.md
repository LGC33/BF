---
weight: 1
title: "CVE-2015-2141"
---
# [CVE-2015-2141](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-2141)

{{< rawhtml >}}
<p>
        <h3>BF Taxonomy</h3>
      </p>
      <ul><strong>Cause: </strong>
        <cause>Modification of Verification Algorithm </cause>by adding a step (blinding)
      </ul>
      <ul><strong>Attributes:</strong>
        <ul>Verified Data: Any <attribute>Secret</attribute>/<attribute>Public</attribute>
        </ul>
        <ul>Data State: <attribute>Transferred </attribute>(over network)</ul>
        <ul>Algorithm: <attribute>Digital Signature </attribute>(Rabin-Williams) (that allows obtaining the private key
          in cases of incorrect unblinding)</ul>
        <ul><u>Security Service</u>: <attribute>Identity Authentication</attribute>
        </ul>
      </ul>
      <ul><strong>Consequence: </strong>
        <consequence>IEX</consequence>
      </ul>
      <p>
        <h3>BF Description</h3>
      </p>
      <ul>
        <cause>Modification of verification algorithm</cause> (<attribute>digital signature</attribute>, Rabin-Williams)
        by adding a step (blinding before signing) allows obtaining the private key in cases of incorrect unblinding,
        which leads to <attribute>identity authentication</attribute> failure and may be exploited for IEX. <a
          href="#ref">[1]</a>
      </ul>
      <p>
        <h3>CVE Description</h3>
      </p>
      <p>
      <ul>"The InvertibleRWFunction::CalculateInverse function in rw.cpp in libcrypt++ 5.6.2 does not properly blind
        private key operations for the Rabin-Williams digital signature algorithm, which allows remote attackers to
        obtain private keys via a timing attack." <a href="#ref">[5]</a></ul>
      </p>
      <p>
        <h3>Analysis</h3>
      </p>
      <p>
      <ul>The following analysis is based on information in <a href="#ref">[6, 7]</a>: Having the private key allows an
        attacker to be authenticated as the owner of that key.
      </ul>
      <ul>The software intends to use blinding to defend against a timing attack, as follows: Instead of signing the
        data directly, the data is first transformed using a secret random value (blinding) and then is digitally signed
        using a private key. At the end, the effect is removed (unblinding), so that there is signed data as if no
        transformation took place. See <a href="#ref">[6, 7]</a> for blinding used for RSA.
      </ul>
      <ul>The flaw in this CVE is in doing blinding/ unblinding incorrectly, so that in some cases the effect of the
        transformation is not removed from the data. This enables the attacker to use the transformed data to recover
        the private key using a mathematical calculation as described in <a href="#ref">[6]</a>. In <a
          href="#ref">[6]</a> it is observed that if the secret random integer used to transform the message is a
        quadratic residue modulo an appropriate integer, then the unblinding step correctly undoes the transformation.
        The fix in <a href="#ref">[20]</a> assures that the integer is such a quadratic residue.
      </ul>
      </p>
      <p>
        <h3>Source Code</h3>
      </p>
      <p>
      <ul>
        <table align="center" class="table-responsive">
          <tr>
            <td align="center"> Code With Bug</td>

          <tr>
            <td>
              <div class="" style="width:auto;">
                <table>
                  <tr>
                    <td>
                      <pre style="margin: 0; line-height: 125%">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
</pre>
                    </td>
                    <td>
                      <pre style="margin: 0; line-height: 125%"><keyword>  DoQuickSanityCheck()</keyword>;
  ModularArithmetic modn(m_n);
  Integer r, rInv;
  <keyword>do</keyword> {<comment>// do this in a loop for people using small numbers for testing</comment>
    r.<keyword>Randomize</keyword>(rng, <keyword>Integer<span style="color: #333333">::</span>One</keyword>(), m_n <span style="color: #333333">-</span> <keyword>Integer<span style="color: #333333">::</span>One</keyword>());


    rInv <span style="color: #333333">=</span> modn.<keyword>MultiplicativeInverse</keyword>(r);
  } <keyword>while</keyword> (rInv.<keyword>IsZero()</keyword>);
  Integer re <span style="color: #333333">=</span> modn.<keyword>Square</keyword>(r);
  re <span style="color: #333333">=</span> modn.<keyword>Multiply</keyword>(re, x);	<comment>// blind</span>
</pre>
                    </td>
                  </tr>
                </table>
              </div>
            </td>
          </tr>
          <td align="center"> Code With Fix</td>
          </tr>
          <td>
            <div class="" style="width:auto;">
              <table>
                <tr>
                  <td>
                    <pre style="margin: 0; line-height: 125%">  1
  2
  3
  4
  5
  <span class="addLine">6
  7</span>
  8
  9
 10
 11
</pre>
                  </td>
                  <td>
                    <pre style="margin: 0; line-height: 125%">  <keyword>DoQuickSanityCheck()</keyword>;
  ModularArithmetic modn(m_n);
  Integer r, rInv;
  <keyword>do</keyword> {<comment>// do this in a loop for people using small numbers for testing</comment>
    r.<keyword>Randomize</keyword>(rng, <keyword><keyword>Integer<span style="color: #333333">::</span>One</keyword></keyword>(), m_n <span style="color: #333333">-</span> <keyword>Integer<span style="color: #333333">::</span>One</keyword>());
    <comment>// Squaring to satisfy Jacobi requirements suggested by JPM.</comment>
    r <span style="color: #333333">=</span> modn.<keyword>Square</keyword>(r);
    rInv <span style="color: #333333">=</span> modn.<keyword>MultiplicativeInverse</keyword>(r);
  } <keyword>while</keyword> (rInv.<keyword>IsZero()</keyword>);
  Integer re <span style="color: #333333">=</span> modn.<keyword>Square</keyword>(r);
  re <span style="color: #333333">=</span> modn.<keyword>Multiply</keyword>(re, x);	<comment>// blind</comment>
</pre>
                  </td>
                </tr>
              </table>
            </div>
          </td>
          </tr>
        </table>
      </ul>
      </p>

      <p class="">
        <h3><a name="ref">References</a></h3>
      </p>
      <small>
        <ul>[1] Bojanova, I., Black, P. E., Yesha, Y., Wu, Yan, Evans, Z., Poster: The Bugs Framework (BF) – First
          Classes: Buffer Overflow (BOF), Injection (INJ), Control of Interaction Frequency (CIF), STC 2017, NIST,
          Gaithersburg, MD, USA.</ul>
        <ul>[2] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, <a target="_blank"
            href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1585">CVE-2001-1585</a>.</ul>
        <ul>[3] <a target="_blank" href="http://www.openbsd.org/advisories/ssh_bypass.txt">OpenBSD Security Advisory,
            Authentication By-Pass Vulnerability in OpenSSH-2.3.1</a>.</ul>
        <ul>[4] S. Tatham, PuTTY User Manual – Chapter 8: "<a target="_blank"
            href="http://the.earth.li/~sgtatham/putty/0.60/htmldoc/Chapter8.html">Using public keys for SSH
            authentication</a>."</ul>
        <ul>[5] The MITRE Corporation, <a target="_blank"
            href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-2141">CVE-2015-2141</a>.</ul>
        <ul>[6] Bugzilla – <a target="_blank" href="https://bugzilla.suse.com/show_bug.cgi?id=936435">Bug 936435, VUL-0:
            CVE-2015-2141: libcryptopp: libcrypto++ -- security update</a>.</ul>
        <ul>[7] E. Sidorov, "<a target="_blank" href="https://eprint.iacr.org/2015/368.pdf">Breaking the Rabin-Williams
            digital signature system implementation in the Crypto++ library</a>."</ul>
        <ul>[8] Wikipedia, <a target="_blank" href="https://en.wikipedia.org/wiki/Blinding_(cryptography)">Blinding
            Cryptography</a>.</ul>
        <ul>[9] Github, <a target="_blank"
            href="https://github.com/weidai11/cryptopp/commit/9425e16437439e68c7d96abef922167d68fafaff?diff=split">Fix
            for CVE-2015-2141</a>.</ul>
      </small>
{{< /rawhtml >}}